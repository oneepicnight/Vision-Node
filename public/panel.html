<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/shared-styles.css">
    <link rel="stylesheet" href="/shared-notifications.css">
    <title>Vision Node - Miner Panel</title>
    <script src="/assets/chart.umd.min.js"></script>
    <script src="/assets/three.min.js"></script>
    <script src="/assets/globe.gl.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Panel-specific styles - use shared vars */
        :root {
            --bg-card: radial-gradient(circle at top, rgba(60, 47, 140, 0.6), rgba(12, 8, 33, 0.85));
            --accent-blue: var(--accent-2);
            --accent-purple: var(--accent);
            --accent-green: var(--green);
            --text-primary: var(--text);
            --text-secondary: var(--muted);
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem 1.2rem;
            background: rgba(138, 92, 255, 0.15);
            border: 1px solid rgba(162, 145, 255, 0.4);
            border-radius: 999px;
            margin-top: 1rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-green);
            animation: pulse 2s infinite;
        }

        .status-dot.syncing {
            background: #fbbf24;
        }

        .status-dot.offline {
            background: #ef4444;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .card {
            background: radial-gradient(circle at top,
                rgba(49, 37, 109, 0.5),
                rgba(12, 8, 33, 0.75));
            border: 1px solid var(--border-color);
            border-radius: 20px;
            padding: 1.5rem;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.7);
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 26px rgba(0, 0, 0, 0.85);
            border-color: rgba(162, 145, 255, 0.5);
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .card-title {
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .card-icon {
            font-size: 1.5rem;
        }

        .card-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            text-shadow: 0 0 6px rgba(140, 180, 255, 0.4);
        }

        .card-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .metric-accent {
            background: linear-gradient(135deg, #c4b5fd 0%, #3cf6d5 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .actions {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }

        .btn {
            flex: 1;
            padding: 1rem 2rem;
            border: none;
            border-radius: 14px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .btn-primary {
            background: linear-gradient(135deg, #8a5cff 0%, #4ad1ff 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 22px rgba(80, 190, 255, 0.7);
        }

        .btn-primary:active {
            transform: translateY(0);
            box-shadow: 0 4px 10px rgba(80, 190, 255, 0.4);
        }

        .btn-secondary {
            background: rgba(138, 92, 255, 0.15);
            color: #c4b5fd;
            border: 1px solid rgba(162, 145, 255, 0.5);
        }

        .btn-secondary:hover {
            transform: translateY(-1px);
            background: rgba(138, 92, 255, 0.25);
            border-color: rgba(162, 145, 255, 0.75);
            box-shadow: 0 8px 22px rgba(80, 190, 255, 0.7);
        }

        .btn-secondary:active {
            transform: translateY(0);
            box-shadow: 0 4px 10px rgba(80, 190, 255, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .mining-active {
            background: linear-gradient(135deg, #3cf6d5, #4ad1ff) !important;
            animation: pulse-glow 2s infinite;
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 20px rgba(60, 246, 213, 0.6); }
            50% { box-shadow: 0 0 40px rgba(60, 246, 213, 0.9); }
        }

        .mining-stats {
            margin: 2rem 0;
        }

        .mining-stat {
            border: 2px solid var(--accent-blue);
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin: 2rem 0;
            background: radial-gradient(circle at top,
                rgba(49, 37, 109, 0.5),
                rgba(12, 8, 33, 0.75));
            border: 1px solid var(--border-color);
            border-radius: 20px;
            padding: 1.5rem;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.7);
        }

        .block-ticker {
            background: radial-gradient(circle at top,
                rgba(49, 37, 109, 0.5),
                rgba(12, 8, 33, 0.75));
            border: 1px solid var(--border-color);
            border-radius: 20px;
            padding: 1.5rem;
            margin: 2rem 0;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.7);
        }

        .block-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            margin-bottom: 0.5rem;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            border-left: 3px solid var(--accent-blue);
            transition: all 0.2s ease;
        }

        .block-item:hover {
            background: var(--bg-card-hover);
            border-left-color: var(--accent-green);
        }

        .block-height {
            font-weight: 700;
            color: var(--accent-blue);
            font-family: 'Courier New', monospace;
        }

        .block-miner {
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }

        .block-miner:hover {
            color: var(--accent-green);
        }

        .block-reward {
            font-weight: 600;
            color: var(--accent-green);
            font-family: 'Courier New', monospace;
        }

        .peer-map {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            padding: 1.5rem;
            margin: 2rem 0;
            max-height: 600px;
            display: flex;
            flex-direction: column;
        }

        .peer-sparkline {
            height: 60px;
            margin-top: 1rem;
            flex-shrink: 0;
        }

        .stats-row {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }

        .stat-chip {
            padding: 0.25rem 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .wallet-box {
            background: var(--bg-card);
            border: 2px solid var(--accent-purple);
            border-radius: 1rem;
            padding: 1.5rem;
            margin: 2rem 0;
        }

        .wallet-input-group {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        .wallet-input {
            flex: 1;
            padding: 0.75rem 1rem;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(162, 145, 255, 0.25);
            border-radius: 14px;
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            transition: border-color 120ms ease-out, box-shadow 120ms ease-out;
        }

        .wallet-input:focus {
            outline: none;
            border-color: rgba(162, 145, 255, 0.6);
            box-shadow: 0 0 0 3px rgba(162, 145, 255, 0.15);
        }

        .wallet-status {
            padding: 0.6rem 1.2rem;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            margin-top: 1rem;
            font-size: 0.85rem;
            border: 1px solid rgba(162, 145, 255, 0.15);
        }

        .peer-list {
            margin-top: 1rem;
            max-height: 300px;
            min-height: 100px;
            overflow-y: auto;
            overflow-x: hidden;
            flex: 1;
        }

        .peer-list::-webkit-scrollbar {
            width: 8px;
        }

        .peer-list::-webkit-scrollbar-track {
            background: #0d1226;
            border-radius: 4px;
        }

        .peer-list::-webkit-scrollbar-thumb {
            background: var(--accent-blue);
            border-radius: 4px;
        }

        .peer-list::-webkit-scrollbar-thumb:hover {
            background: var(--accent-purple);
        }

        .peer-item {
            padding: 0.75rem;
            background: #0d1226;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            flex-shrink: 0;
            min-height: 50px;
        }

        .peer-url {
            font-family: 'Courier New', monospace;
            color: var(--text-secondary);
            word-break: break-all;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 400px;
        }

        .load-more-btn {
            width: 100%;
            padding: 0.75rem;
            margin-top: 1rem;
            background: var(--bg-card-hover);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .load-more-btn:hover {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }

        /* Metrics Overlay */
        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 14, 39, 0.95);
            backdrop-filter: blur(10px);
            z-index: 1000;
            overflow-y: auto;
        }

        .overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .overlay-content {
            background: var(--bg-card);
            border: 2px solid var(--accent-blue);
            border-radius: 1rem;
            padding: 2rem;
            max-width: 900px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }

        .close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 2rem;
            cursor: pointer;
            padding: 0.5rem;
            line-height: 1;
        }

        .close-btn:hover {
            color: var(--accent-blue);
        }

        /* Activity Log Filters */
        .log-filters {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .filter-chip {
            padding: 0.5rem 1rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        .filter-chip:hover, .filter-chip.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        .search-box {
            flex: 1;
            min-width: 200px;
            padding: 0.5rem 1rem;
            background: #0d1226;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            color: var(--text-primary);
        }

        .search-box:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        /* Rig Health */
        .rig-health {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            padding: 1.5rem;
            margin: 2rem 0;
        }

        .health-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .health-card {
            background: #0d1226;
            border-radius: 0.5rem;
            padding: 1rem;
            text-align: center;
        }

        .health-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-green);
            margin: 0.5rem 0;
        }

        .health-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .temp-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.75rem;
            font-weight: 600;
            margin-top: 0.5rem;
        }

        .temp-normal { background: var(--accent-green); color: white; }
        .temp-warm { background: #fbbf24; color: #000; }
        .temp-hot { background: #ef4444; color: white; }

        /* Geo Map - 3D Spinning Globe with Starfield */
        .geo-map {
            background: #000;
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            padding: 0;
            margin: 2rem 0;
            overflow: hidden;
            position: relative;
        }

        #peer-map {
            height: 600px;
            width: 100%;
            background: 
                radial-gradient(2px 2px at 20% 30%, white, transparent),
                radial-gradient(2px 2px at 60% 70%, white, transparent),
                radial-gradient(1px 1px at 50% 50%, white, transparent),
                radial-gradient(1px 1px at 80% 10%, white, transparent),
                radial-gradient(2px 2px at 90% 60%, white, transparent),
                radial-gradient(1px 1px at 33% 80%, white, transparent),
                radial-gradient(2px 2px at 75% 25%, white, transparent),
                radial-gradient(1px 1px at 15% 60%, white, transparent),
                radial-gradient(2px 2px at 45% 15%, white, transparent),
                radial-gradient(1px 1px at 70% 85%, white, transparent),
                radial-gradient(ellipse at bottom, #1B2735 0%, #090A0F 100%);
            background-size: 
                200px 200px,
                300px 300px,
                250px 250px,
                150px 150px,
                280px 280px,
                220px 220px,
                180px 180px,
                240px 240px,
                320px 320px,
                190px 190px,
                100% 100%;
            background-position: 0 0;
            position: relative;
        }

        /* Subtle shooting stars */
        .shooting-star {
            position: absolute;
            width: 1px;
            height: 80px;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.9), transparent);
            animation: shoot 4s ease-in infinite;
            opacity: 0;
            z-index: 1;
        }

        @keyframes shoot {
            0% {
                transform: translateX(0) translateY(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 0.3;
            }
            100% {
                transform: translateX(-200px) translateY(200px);
                opacity: 0;
            }
        }

        /* Slow rotating Milky Way cloud */
        .milky-way {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background: radial-gradient(ellipse at 30% 50%, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
            animation: milkyway 180s linear infinite;
            opacity: 0.4;
            z-index: 1;
            pointer-events: none;
        }

        @keyframes milkyway {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .globe-title {
            position: absolute;
            top: 1rem;
            left: 1rem;
            color: #fff;
            font-size: 1.2rem;
            font-weight: 600;
            z-index: 100;
            text-shadow: 0 2px 8px rgba(0,0,0,0.9);
        }

        .globe-stats {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            color: #ef4444;
            font-size: 1.5rem;
            font-weight: 700;
            z-index: 100;
            text-shadow: 0 2px 8px rgba(0,0,0,0.9);
        }

        .ws-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            font-size: 0.75rem;
            margin-left: 1rem;
        }

        .ws-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-green);
        }

        .ws-dot.disconnected {
            background: #ef4444;
        }

        .log-container {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            padding: 1.5rem;
            margin-top: 2rem;
        }

        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .log-title {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .log-content {
            background: #0d1226;
            border-radius: 0.5rem;
            padding: 1rem;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.8;
        }

        .log-entry {
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
        }

        .log-entry-success {
            color: var(--accent-green);
        }

        .log-entry-error {
            color: #ff6b6b;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .footer {
            text-align: center;
            margin-top: 4rem;
            padding: 2rem 0;
            border-top: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .endpoint-list {
            margin-top: 1rem;
        }

        .endpoint-item {
            padding: 0.75rem;
            background: #0d1226;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
        }

        .endpoint-method {
            padding: 0.25rem 0.5rem;
            background: var(--accent-blue);
            color: white;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .endpoint-method.post {
            background: var(--accent-green);
        }

        /* Constellation Sync Status Styles */
        .constellation-card {
            background: radial-gradient(circle at top, rgba(60, 47, 140, 0.4), rgba(12, 8, 33, 0.7));
            border: 2px solid rgba(162, 145, 255, 0.3);
            border-radius: 20px;
            padding: 2rem;
            margin: 2rem 0;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
            transition: all 0.3s ease;
        }

        .constellation-card.ready {
            border-color: rgba(60, 246, 213, 0.6);
            box-shadow: 0 10px 40px rgba(60, 246, 213, 0.3);
        }

        .constellation-header {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .constellation-star {
            font-size: 3rem;
            animation: starPulse 2s infinite;
            filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.6));
        }

        .constellation-star::before {
            content: "‚≠ê";
        }

        .constellation-card.ready .constellation-star {
            animation: starReady 1.5s infinite;
        }

        .constellation-card.ready .constellation-star::before {
            content: "‚ú®";
        }

        @keyframes starPulse {
            0%, 100% {
                opacity: 0.5;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.15);
            }
        }

        @keyframes starReady {
            0%, 100% {
                opacity: 0.8;
                transform: rotate(0deg) scale(1);
            }
            50% {
                opacity: 1;
                transform: rotate(180deg) scale(1.1);
            }
        }

        .constellation-text h3 {
            font-size: 1.5rem;
            color: var(--accent-purple);
            margin-bottom: 0.5rem;
        }

        .constellation-text p {
            font-size: 0.95rem;
            color: var(--text-secondary);
            margin: 0;
        }

        .constellation-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .constellation-metrics > div {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(162, 145, 255, 0.2);
            border-radius: 12px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .metric-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .metric-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent-blue);
            font-family: 'Courier New', monospace;
        }

        .mine-hint {
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-align: center;
            margin: 1rem 0 0 0;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(162, 145, 255, 0.15);
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            h1 {
                font-size: 2rem;
            }

            .grid {
                grid-template-columns: 1fr;
            }

            .actions {
                flex-direction: column;
            }

            .constellation-star {
                font-size: 2rem;
            }

            .constellation-text h3 {
                font-size: 1.2rem;
            }

            .constellation-metrics {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <nav class="vision-nav">
        <div class="vision-nav-content">
            <div class="vision-nav-left">
                <a href="/app" class="vision-nav-logo">
                    <span style="font-size: 20px;">‚õèÔ∏è</span>
                    <span>Vision</span>
                </a>
                <div class="vision-nav-links">
                    <a href="/app" class="vision-nav-link">Wallet</a>
                    <a href="/dashboard.html" class="vision-nav-link">Dashboard</a>
                    <a href="/panel.html" class="vision-nav-link active">Miner</a>
                    <a href="/governance.html" class="vision-nav-link">Governance</a>
                </div>
            </div>
            <div class="vision-nav-right">
                <!-- Discord Link Button -->
                <button id="discord-link-btn" class="btn btn-secondary" style="display: none; padding: 0.5rem 1rem; font-size: 0.85rem; margin-right: 1rem;">
                    üîó Link Discord
                </button>
                <div id="discord-status" style="display: none; margin-right: 1rem; padding: 0.5rem 1rem; background: rgba(0, 255, 136, 0.15); border: 1px solid rgba(0, 255, 136, 0.5); border-radius: 8px; font-size: 0.85rem;">
                    <span style="color: var(--accent-green);">‚úì</span>
                    <span id="discord-username" style="color: var(--accent-green);">Discord</span>
                </div>
                <div class="vision-status-dot"></div>
                <span style="font-size: 12px; color: var(--muted);" id="status-text">Mining</span>
            </div>
        </div>
    </nav>

    <div class="vision-container">
        <!-- TESTNET SUNSET MESSAGE (hidden by default, shown when expired) -->
        <div id="sunset-banner" style="display: none; margin-bottom: 2rem; padding: 2rem; background: linear-gradient(135deg, rgba(251, 191, 36, 0.2), rgba(239, 68, 68, 0.2)); border: 2px solid #fbbf24; border-radius: 1rem; text-align: center;">
            <div style="font-size: 3rem; margin-bottom: 1rem;">üåÖ</div>
            <h1 style="font-size: 2rem; color: #fbbf24; margin-bottom: 1rem; font-weight: 700;">Thank You for Participating in Vision Testnet!</h1>
            <p style="font-size: 1.2rem; color: var(--text-primary); margin-bottom: 1rem; line-height: 1.6;">
                The testnet has reached its sunset date. Your participation has been invaluable in helping us build Vision.
            </p>
            <div style="padding: 1.5rem; background: rgba(0,0,0,0.3); border-radius: 0.75rem; margin-bottom: 1rem;">
                <p style="color: var(--accent-green); font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem;">‚úÖ Mainnet Launch</p>
                <p style="color: var(--text-secondary); font-size: 1rem;">Mainnet will be available within 24 hours</p>
            </div>
            <div style="color: var(--text-secondary); font-size: 0.95rem; line-height: 1.6;">
                <p style="margin-bottom: 0.5rem;">All testnet data has been preserved.</p>
                <p>This node has been permanently locked and is running in read-only mode.</p>
            </div>
        </div>

        <header style="text-align: center; margin-bottom: 2rem;">
            <h1 class="vision-title">‚õèÔ∏è Miner Control Panel</h1>
            <p class="vision-subtitle">Mainnet</p>
            
            <!-- Anchor Mode Toggle -->
            <div id="anchorModeContainer" style="margin-top: 1rem;"></div>
        </header>

        <div class="grid">
            <div class="card">
                <div class="card-header">
                    <span class="card-title">Block Height</span>
                    <span class="card-icon">üì¶</span>
                </div>
                <div class="card-value metric-accent" id="height">--</div>
                <div class="card-label">Current chain height</div>
            </div>

            <div class="card">
                <div class="card-header">
                    <span class="card-title">Connected Peers</span>
                    <span class="card-icon">üåê</span>
                </div>
                <div class="card-value" id="peers">--</div>
                <div class="card-label">Active network connections</div>
            </div>

            <div class="card">
                <div class="card-header">
                    <span class="card-title">Total Supply</span>
                    <span class="card-icon">üí∞</span>
                </div>
                <div class="card-value" id="supply">--</div>
                <div class="card-label">Circulating tokens</div>
            </div>

            <div class="card">
                <div class="card-header">
                    <span class="card-title">Mempool Size</span>
                    <span class="card-icon">‚è≥</span>
                </div>
                <div class="card-value" id="mempool">--</div>
                <div class="card-label">Pending transactions</div>
            </div>

            <div class="card">
                <div class="card-header">
                    <span class="card-title">P2P Reachability</span>
                    <span class="card-icon">üåê</span>
                </div>
                <div class="card-value" id="p2p-reachable" style="font-size: 1rem;">Checking...</div>
                <div class="card-label" id="p2p-advertised">--</div>
            </div>

            <div class="card">
                <div class="card-header">
                    <span class="card-title">Node Identity</span>
                    <span class="card-icon">üÜî</span>
                </div>
                <div class="card-value" id="node-id-display" style="font-size: 0.9rem; font-family: 'Courier New', monospace; word-break: break-all;">--</div>
                <div class="card-label" id="wallet-address-display">Wallet: --</div>
            </div>
        </div>

        <!-- Connection Readiness (P2P Health) -->
        <div style="margin-top: 1.5rem;">
            <div id="connection-readiness" style="padding: 0.75rem; background: rgba(0, 212, 255, 0.1); border: 1px solid var(--accent-blue); border-radius: 0.5rem; font-size: 0.9rem; display: flex; align-items: center; gap: 0.75rem;">
                <span id="connection-readiness-icon" style="font-size: 1.2rem;">üîÑ</span>
                <div style="flex: 1;">
                    <div id="connection-readiness-text" style="color: var(--accent-cyan); font-weight: 500;">
                        Checking P2P Health...
                    </div>
                    <div id="connection-readiness-detail" style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 0.25rem;">
                        Initializing network connection status
                    </div>
                </div>
            </div>
        </div>

        <!-- Mining Stats -->
        <div class="mining-stats">
            <h2 style="margin-bottom: 1.5rem; font-size: 1.5rem;">‚õèÔ∏è Mining Statistics</h2>
            <div class="grid">
                <div class="card mining-stat">
                    <div class="card-header">
                        <span class="card-title">Blocks Mined</span>
                        <span class="card-icon">üéØ</span>
                    </div>
                    <div class="card-value metric-accent" id="total-mined">0</div>
                    <div class="card-label">Total blocks produced</div>
                </div>

                <div class="card mining-stat">
                    <div class="card-header">
                        <span class="card-title">Success Rate</span>
                        <span class="card-icon">üìà</span>
                    </div>
                    <div class="card-value" id="success-rate">100%</div>
                    <div class="card-label">Mining efficiency</div>
                </div>

                <div class="card mining-stat">
                    <div class="card-header">
                        <span class="card-title">Avg Block Time</span>
                        <span class="card-icon">‚ö°</span>
                    </div>
                    <div class="card-value" id="avg-time">0ms</div>
                    <div class="card-label">Average mining duration</div>
                </div>
            </div>
        </div>

        <!-- Constellation Sync Status Card -->
        <div id="constellation-status" class="constellation-card">
            <div class="constellation-header">
                <span class="constellation-star"></span>
                <div class="constellation-text">
                    <h3>Joining the Constellation</h3>
                    <p id="constellation-subtitle">Syncing with fellow stars across the network‚Ä¶</p>
                </div>
            </div>
            
            <div class="constellation-metrics">
                <div><span class="metric-label">Local height</span><span id="metric-sync-height" class="metric-value">0</span></div>
                <div><span class="metric-label">Network height</span><span id="metric-network-height" class="metric-value">0</span></div>
                <div><span class="metric-label">Connected peers</span><span id="metric-peers" class="metric-value">0</span></div>
            </div>
            
            <p id="mine-hint" class="mine-hint">Mining unlocks after your node is fully synced and sees at least 2 peers on the same chain.</p>
        </div>

        <!-- HTTP Backbone (7070) Status Card -->
        <div class="constellation-card" style="margin-top: 1.5rem;">
            <div class="constellation-header">
                <span class="constellation-star">üåê</span>
                <div class="constellation-text">
                    <h3>Backbone (7070)</h3>
                    <p id="backbone-subtitle">Connecting to anchor truth...</p>
                </div>
            </div>
            
            <div class="constellation-metrics">
                <div><span class="metric-label">Status</span><span id="backbone-status" class="metric-value">‚è≥ Probing</span></div>
                <div><span class="metric-label">Anchor</span><span id="backbone-anchor" class="metric-value">‚Äî</span></div>
                <div><span class="metric-label">Latency</span><span id="backbone-latency" class="metric-value">‚Äî</span></div>
                <div><span class="metric-label">Tip Height</span><span id="backbone-tip" class="metric-value">‚Äî</span></div>
            </div>
            
            <p class="mine-hint" style="border-color: rgba(99, 102, 241, 0.3); background: rgba(99, 102, 241, 0.05);">
                <span id="exchange-status">üè¶ Exchange: Checking...</span>
            </p>
        </div>

        <!-- Website Integration Status Card -->
        <div class="constellation-card" style="margin-top: 1.5rem;">
            <div class="constellation-header">
                <span class="constellation-star">üåç</span>
                <div class="constellation-text">
                    <h3>Website Integration</h3>
                    <p>Heartbeat to visionworld.tech</p>
                </div>
            </div>
            
            <div class="constellation-metrics">
                <div><span class="metric-label">Status</span><span id="website-status" class="metric-value">‚è≥ Starting...</span></div>
                <div><span class="metric-label">Last Heartbeat</span><span id="website-last-heartbeat" class="metric-value">‚Äî</span></div>
                <div><span class="metric-label">HTTP Status</span><span id="website-http-status" class="metric-value">‚Äî</span></div>
                <div><span class="metric-label">Success Rate</span><span id="website-success-rate" class="metric-value">‚Äî</span></div>
            </div>
            
            <p class="mine-hint" style="border-color: rgba(99, 102, 241, 0.3); background: rgba(99, 102, 241, 0.05);">
                <span id="constellation-link-status">üîó Constellation: Loading...</span>
            </p>
        </div>

        <!-- Ready Status Card -->
        <div class="constellation-card" style="margin-top: 1.5rem;">
            <div class="constellation-header">
                <span class="constellation-star" id="ready-icon">‚è≥</span>
                <div class="constellation-text">
                    <h3>Node Readiness</h3>
                    <p id="ready-subtitle">Checking status...</p>
                </div>
            </div>
            
            <div class="constellation-metrics">
                <div><span class="metric-label">Backbone</span><span id="ready-backbone" class="metric-value">‚Äî</span></div>
                <div><span class="metric-label">Chain Sync</span><span id="ready-sync" class="metric-value">‚Äî</span></div>
                <div><span class="metric-label">Website</span><span id="ready-website" class="metric-value">‚Äî</span></div>
                <div><span class="metric-label">Approval</span><span id="ready-approval" class="metric-value">‚Äî</span></div>
            </div>
            
            <p id="ready-message" class="mine-hint">Node is initializing...</p>
        </div>

        <!-- Network Status -->
        <div style="margin-top: 1rem; padding: 1rem; background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(59, 130, 246, 0.2)); border: 2px solid var(--accent-green); border-radius: 0.75rem;">
            <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem;">
                <span style="font-size: 1.5rem;">‚õèÔ∏è</span>
                <div>
                    <div style="font-weight: 600; color: var(--accent-green); font-size: 1rem;">Traditional PoW Mining</div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem;">Every block requires cryptographic proof-of-work</div>
                </div>
            </div>
            <div style="padding: 0.75rem; background: rgba(0,0,0,0.3); border-radius: 0.5rem; font-size: 0.85rem; color: var(--text-secondary); line-height: 1.6;">
                <strong style="color: var(--accent-cyan);">Vision Network</strong><br>
                Mining new blocks: <strong style="color: var(--accent-green);">Active</strong><br>
                Keep your node synced and linked to participate in block mining and earn rewards.
            </div>
        </div>

        <!-- Node Identity Card -->
        <div class="constellation-card" style="margin-top: 1.5rem;">
            <div class="constellation-header">
                <span class="constellation-star">üîë</span>
                <div class="constellation-text">
                    <h3>Node Identity</h3>
                    <p>Cryptographic Ed25519 identity</p>
                </div>
            </div>
            
            <div class="constellation-metrics">
                <div style="grid-column: 1 / -1;">
                    <span class="metric-label">Node ID</span>
                    <span id="node-id" class="metric-value" style="font-family: monospace; font-size: 0.85rem; word-break: break-all;">Loading...</span>
                </div>
                <div style="grid-column: 1 / -1;">
                    <span class="metric-label">Pubkey FPR</span>
                    <span id="node-fingerprint" class="metric-value" style="font-family: monospace; font-size: 0.9rem; color: var(--accent-blue);">Loading...</span>
                </div>
                <div style="grid-column: 1 / -1;">
                    <span class="metric-label">Public Key</span>
                    <span id="node-pubkey" class="metric-value" style="font-family: monospace; font-size: 0.75rem; word-break: break-all;">Loading...</span>
                </div>
                <div style="grid-column: 1 / -1;">
                    <span class="metric-label">Approval</span>
                    <span id="approval-status" class="metric-value">‚è≥ Loading...</span>
                </div>
            </div>
            
            <p class="mine-hint" style="border-color: rgba(16, 185, 129, 0.3); background: rgba(16, 185, 129, 0.05);">
                <span id="identity-status">‚úÖ Identity: Verified (Ed25519-derived)</span>
            </p>
        </div>

        <!-- Link Wallet to Node -->
        <div class="wallet-box">
            <h2 style="margin-bottom: 1rem; font-size: 1.3rem;">üîê Link Wallet to Node</h2>
            <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                Enter your wallet address to link it with this node and enable mining
            </p>
            <div class="wallet-input-group" style="flex-direction: column; gap: 1rem;">
                <div class="wallet-status" id="node-identity-status" style="margin: 0;">
                    <span style="color: var(--text-secondary);">Node ID: </span>
                    <span id="node-id-display-link" style="color: var(--accent-blue); font-family: 'Courier New', monospace; font-size: 0.85rem;">Loading...</span>
                </div>
                <div class="wallet-status" id="approval-status-link" style="margin: 0;">
                    <span style="color: var(--text-secondary);">Status: </span>
                    <span id="approval-state" style="color: #fbbf24; font-weight: 600;">Not Linked</span>
                </div>
                <div class="wallet-status" id="wallet-status" style="margin: 0;">
                    <span style="color: var(--text-secondary);">Linked Wallet: </span>
                    <span id="current-wallet" style="color: var(--accent-green); font-family: 'Courier New', monospace;">None</span>
                </div>
                <div class="wallet-status" id="pending-rewards-status" style="margin: 0;">
                    <span style="color: var(--text-secondary);">Pending Rewards: </span>
                    <span id="pending-rewards-display" style="color: #fbbf24; font-family: 'Courier New', monospace; font-weight: 600;">0 LAND</span>
                </div>
                
                <div style="margin-top: 1rem;">
                    <label style="display: block; color: var(--text-secondary); margin-bottom: 0.5rem; font-size: 0.9rem;">
                        Your Wallet Address (from /app#/wallet)
                    </label>
                    <input 
                        type="text" 
                        id="wallet-address-input" 
                        placeholder="0x..." 
                        style="width: 100%; padding: 0.75rem; background: rgba(12, 8, 33, 0.6); border: 1px solid var(--border-color); border-radius: 0.5rem; color: var(--text-primary); font-family: 'Courier New', monospace; font-size: 0.9rem;"
                    />
                </div>
                
                <button class="btn btn-primary" id="link-node-btn" style="min-width: 200px;">
                    <span>üîó</span>
                    <span>Link Node</span>
                </button>
                
                <div id="mining-block-reason" style="color: #fbbf24; font-size: 0.9rem; display: none;">
                    <!-- Shows mining_blocked_reason when present -->
                </div>
            </div>
        </div>

        <!-- Miner Thread Control -->
        <div class="wallet-box">
            <h2 style="margin-bottom: 1rem; font-size: 1.3rem;">‚öôÔ∏è Mining Control</h2>
            
            <!-- Mining Status Banner -->
            <div style="margin-bottom: 1.5rem; padding: 1rem; background: linear-gradient(135deg, rgba(139, 92, 246, 0.15), rgba(59, 130, 246, 0.15)); border: 2px solid var(--accent-purple); border-radius: 0.75rem;">
                <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem;">
                    <span style="font-size: 1.5rem;">‚õèÔ∏è</span>
                    <div>
                        <div style="font-weight: 600; color: var(--accent-purple); font-size: 1rem;">Mining Status</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem;">Mining runs when the node is synced and healthy</div>
                    </div>
                </div>
                <div style="padding: 0.75rem; background: rgba(0,0,0,0.3); border-radius: 0.5rem; font-size: 0.9rem;">
                    <div style="color: var(--text-secondary); margin-bottom: 0.25rem;">
                        <strong style="color: var(--accent-cyan);">üí° How it works:</strong>
                    </div>
                    <ul style="margin: 0.5rem 0 0 1.25rem; padding: 0; color: var(--text-secondary); font-size: 0.85rem; line-height: 1.6;">
                        <li><strong>Traditional Proof-of-Work mining</strong></li>
                        <li>Every block requires computational work</li>
                        <li>Mining rewards distributed to block miners</li>
                        <li>Link wallet + sync node + mine blocks = earn!</li>
                    </ul>
                </div>
                
                <!-- Optional Mining (Fans Go Brr) -->
                <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(255, 183, 77, 0.1); border: 1px dashed #ffb74d; border-radius: 0.5rem;">
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                        <span style="font-size: 1.2rem;">üî•</span>
                        <strong style="color: #ffb74d; font-size: 0.9rem;">Want to hear your fans?</strong>
                    </div>
                    <p style="margin: 0 0 0.75rem 0; color: var(--text-secondary); font-size: 0.85rem; line-height: 1.5;">
                        Start active mining to dedicate CPU power to finding new blocks.
                        Higher hashrate increases your chances of mining blocks and earning rewards.
                    </p>
                    <button class="btn btn-primary" id="make-fans-go-brr-btn" style="width: 100%; padding: 1rem; font-size: 1rem; font-weight: 600;">
                        <span style="font-size: 1.2rem;">üí®</span>
                        <span>Make Fans Go BRRRR!</span>
                    </button>
                    <button class="btn btn-secondary" id="stop-fans-btn" style="width: 100%; margin-top: 0.5rem; padding: 0.75rem; display: none;">
                        <span>üõë</span>
                        <span>Stop Mining (fans will quiet down)</span>
                    </button>
                    <div style="margin-top: 0.5rem; color: var(--text-secondary); font-size: 0.85rem; text-align: center;">
                        Status: <strong id="fan-status" style="color: var(--accent-cyan);">Quiet (no mining)</strong>
                    </div>
                </div>
            </div>
            
            <!-- Mining Mode Selector -->
            <div style="margin-bottom: 1.5rem;">
                <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                    Mining Mode:
                </label>
                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                    <button class="btn btn-secondary mining-mode-btn" data-mode="Solo" style="flex: 1; min-width: 120px; padding: 0.75rem;">
                        ‚õèÔ∏è Solo
                    </button>
                    <button class="btn btn-secondary mining-mode-btn" data-mode="HostPool" style="flex: 1; min-width: 120px; padding: 0.75rem;">
                        üèä Host Pool
                    </button>
                    <button class="btn btn-secondary mining-mode-btn" data-mode="JoinPool" style="flex: 1; min-width: 120px; padding: 0.75rem;">
                        ü§ù Join Pool
                    </button>
                    <button class="btn btn-secondary mining-mode-btn" data-mode="Farm" style="flex: 1; min-width: 120px; padding: 0.75rem;">
                        üöú Farm
                    </button>
                </div>
                <div style="margin-top: 0.5rem; padding: 0.75rem; background: #0d1226; border-radius: 0.5rem; font-size: 0.85rem; color: var(--text-secondary);">
                    <span id="mode-description">Solo: Mine independently and receive full block rewards</span>
                </div>
            </div>

            <div class="wallet-input-group" style="flex-direction: column; gap: 1rem;">
                <!-- Mining Performance Tuning -->
                <div style="margin-bottom: 1.5rem; padding: 1rem; background: rgba(99, 102, 241, 0.05); border-radius: 0.5rem;">
                    <h3 style="margin: 0 0 1rem 0; font-size: 1rem; color: var(--accent-blue);">üéØ Performance Tuning</h3>
                    
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                            Mining Profile:
                        </label>
                        <select id="miningProfile" class="wallet-input" style="width: 100%; padding: 0.75rem;">
                            <option value="laptop">üíª Laptop (low impact)</option>
                            <option value="balanced" selected>‚öñÔ∏è Balanced</option>
                            <option value="beast">üî• Beast Mode (all cores)</option>
                        </select>
                        <small style="display: block; margin-top: 0.25rem; color: var(--text-secondary); font-size: 0.8rem;">
                            Choose how aggressive mining should be: Laptop = gentle, Balanced = smart, Beast = all cores unleashed.
                        </small>
                    </div>

                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                            Mining Threads (override):
                        </label>
                        <input 
                            type="number" 
                            id="miningThreads" 
                            class="wallet-input" 
                            min="0" 
                            placeholder="0 = auto (based on profile)"
                            style="width: 100%; padding: 0.75rem;"
                        />
                        <small style="display: block; margin-top: 0.25rem; color: var(--text-secondary); font-size: 0.8rem;">
                            Leave 0 or empty to auto-detect from CPU and profile. Set a number to force a specific thread count.
                        </small>
                    </div>

                    <div style="margin-bottom: 0;">
                        <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                            SIMD Batch Size:
                        </label>
                        <input 
                            type="number" 
                            id="simdBatchSize" 
                            class="wallet-input" 
                            min="1" 
                            max="1024" 
                            value="4"
                            style="width: 100%; padding: 0.75rem;"
                        />
                        <small style="display: block; margin-top: 0.25rem; color: var(--text-secondary); font-size: 0.8rem;">
                            How many nonces to process per inner loop. 1 = old behavior, 4‚Äì8 = good for performance, higher = more aggressive.
                        </small>
                    </div>
                </div>

                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span style="color: var(--text-secondary);">
                        Mining Threads: <strong id="current-threads" style="color: var(--accent-green);">--</strong> / 
                        <span id="max-threads">--</span>
                    </span>
                    <span id="mining-status" style="color: var(--text-secondary);">
                        Status: <strong style="color: var(--text-secondary);">--</strong>
                    </span>
                </div>
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <input 
                        type="range" 
                        id="thread-slider" 
                        min="0" 
                        max="1" 
                        value="0" 
                        step="1"
                        style="flex: 1; height: 8px; border-radius: 4px; background: var(--card-bg); cursor: pointer;"
                        disabled
                    />
                    <button class="btn btn-primary" id="apply-threads-btn" style="min-width: 120px;" disabled>
                        <span>‚úÖ</span>
                        <span>Apply</span>
                    </button>
                </div>
                <div style="color: var(--text-secondary); font-size: 0.9rem;">
                    Current Hashrate: <strong id="current-hashrate" style="color: var(--accent-cyan);">0 H/s</strong>
                </div>
            </div>
        </div>

        <!-- Pool Configuration (shown for HostPool and JoinPool modes) -->
        <div class="wallet-box" id="pool-config" style="display: none;">
            <h2 style="margin-bottom: 1rem; font-size: 1.3rem;">üèä Pool Configuration</h2>
            
            <!-- Foundation Fee Notice -->
            <div style="margin-bottom: 1rem; padding: 0.75rem; background: rgba(185, 104, 255, 0.1); border: 1px solid var(--accent-purple); border-radius: 0.5rem; font-size: 0.85rem;">
                <strong style="color: var(--accent-purple);">‚ÑπÔ∏è Fee Structure:</strong>
                <div style="margin-top: 0.25rem; color: var(--text-secondary);">
                    ‚Ä¢ Foundation: 1% (supports development)<br>
                    ‚Ä¢ Pool Fee: <span id="current-pool-fee">1.5%</span> (default, configurable for hosts)
                </div>
            </div>

            <!-- Host Pool Settings -->
            <div id="host-pool-settings" style="display: none;">
                <div style="margin-bottom: 1rem;">
                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                        Pool Name:
                    </label>
                    <input 
                        type="text" 
                        id="pool-name-input" 
                        class="wallet-input" 
                        placeholder="My Awesome Pool"
                        value=""
                        maxlength="50"
                    />
                </div>
                <div style="margin-bottom: 1rem;">
                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                        Pool Port:
                    </label>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn btn-secondary pool-port-btn" data-port="7072" style="flex: 1; padding: 0.75rem;">
                            7072
                        </button>
                        <button class="btn btn-secondary pool-port-btn" data-port="8082" style="flex: 1; padding: 0.75rem;">
                            8082
                        </button>
                    </div>
                </div>
                <div style="margin-bottom: 1rem;">
                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                        Pool Fee Percentage:
                    </label>
                    <div style="display: flex; gap: 1rem; align-items: center;">
                        <input 
                            type="number" 
                            id="pool-fee-input" 
                            class="wallet-input" 
                            placeholder="1.5"
                            value="1.5"
                            min="0"
                            max="10"
                            step="0.1"
                            style="flex: 1;"
                        />
                        <span style="color: var(--text-secondary);">%</span>
                    </div>
                </div>
                <div style="display: flex; gap: 1rem;">
                    <button class="btn btn-primary" id="start-pool-btn" style="flex: 1;">
                        <span>‚ñ∂Ô∏è</span>
                        <span>Start Pool</span>
                    </button>
                    <button class="btn btn-secondary" id="stop-pool-btn" style="flex: 1; display: none;">
                        <span>‚èπÔ∏è</span>
                        <span>Stop Pool</span>
                    </button>
                </div>
                <div style="margin-top: 0.5rem; color: var(--text-secondary); font-size: 0.85rem;">
                    Pool Status: <strong id="pool-status" style="color: var(--accent-green);">Stopped</strong>
                </div>
                <div id="pool-url-display" style="display: none; margin-top: 1rem; padding: 1.25rem; background: linear-gradient(135deg, rgba(0, 212, 255, 0.15), rgba(0, 212, 255, 0.05)); border: 2px solid var(--accent-blue); border-radius: 0.75rem; box-shadow: 0 4px 12px rgba(0, 212, 255, 0.2);">
                    <div style="margin-bottom: 0.75rem;">
                        <div style="color: var(--accent-blue); font-size: 0.95rem; font-weight: 600; margin-bottom: 0.25rem;">
                            üèä <span id="pool-name-display" style="display: none;"></span>
                        </div>
                        <div style="color: var(--accent-blue); font-size: 0.9rem; font-weight: 600; margin-bottom: 0.25rem;">
                            üåê POOL ADDRESS
                        </div>
                        <div style="color: var(--text-secondary); font-size: 0.8rem;">
                            Share this with miners to join your pool
                        </div>
                    </div>
                    <div style="display: flex; gap: 0.75rem; align-items: center;">
                        <input 
                            type="text" 
                            id="pool-url-generated" 
                            class="wallet-input" 
                            readonly
                            style="flex: 1; font-family: 'Courier New', monospace; background: #0d1226; font-size: 0.95rem; padding: 0.85rem; border: 1px solid var(--accent-blue); font-weight: 500; color: var(--accent-blue);"
                        />
                        <button class="btn btn-primary" onclick="copyToClipboard(document.getElementById('pool-url-generated').value)" style="min-width: 120px; padding: 0.85rem; font-weight: 600; font-size: 0.9rem;">
                            üìã Copy URL
                        </button>
                    </div>
                    <div style="margin-top: 0.75rem; display: flex; gap: 0.5rem; align-items: start;">
                        <span style="color: var(--accent-blue); font-size: 1rem;">üí°</span>
                        <div style="color: var(--text-secondary); font-size: 0.8rem; line-height: 1.4;">
                            Workers paste this URL in their "Join Pool" section to start mining for your pool
                        </div>
                    </div>
                </div>
            </div>

            <!-- Join Pool Settings -->
            <div id="join-pool-settings" style="display: none;">
                <div style="margin-bottom: 1rem;">
                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                        Worker Name:
                    </label>
                    <input 
                        type="text" 
                        id="worker-name-input" 
                        class="wallet-input" 
                        placeholder="My Mining Rig"
                        value=""
                        maxlength="32"
                    />
                </div>
                <div style="margin-bottom: 1rem;">
                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                        Pool URL:
                    </label>
                    <input 
                        type="text" 
                        id="pool-url-input" 
                        class="wallet-input" 
                        placeholder="http://pool.example.com:7070"
                        value=""
                    />
                </div>
                <button class="btn btn-primary" id="join-pool-btn" style="width: 100%; margin-bottom: 0.5rem;">
                    <span>ü§ù</span>
                    <span>Connect to Pool</span>
                </button>
                <button class="btn btn-secondary" id="disconnect-pool-btn" style="width: 100%; display: none;">
                    <span>üîå</span>
                    <span>Disconnect from Pool</span>
                </button>
                <div style="margin-top: 0.5rem; color: var(--text-secondary); font-size: 0.85rem;">
                    Connection: <strong id="join-pool-status" style="color: var(--text-secondary);">Not connected</strong>
                </div>
                <div id="pool-info-display" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: rgba(0, 212, 255, 0.1); border: 1px solid var(--accent-blue); border-radius: 0.5rem; font-size: 0.85rem;">
                    <div style="color: var(--text-secondary); margin-bottom: 0.25rem;">
                        Pool: <strong id="connected-pool-name" style="color: var(--accent-blue);">-</strong>
                    </div>
                    <div style="color: var(--text-secondary);">
                        Workers: <strong id="connected-pool-workers" style="color: var(--accent-blue);">-</strong> | 
                        Hashrate: <strong id="connected-pool-hashrate" style="color: var(--accent-blue);">-</strong>
                    </div>
                </div>
            </div>
        </div>

        <!-- Pool Statistics (shown when pool is active) -->
        <div class="mining-stats" id="pool-stats" style="display: none;">
            <h2 style="margin-bottom: 1.5rem; font-size: 1.5rem;">
                üèä <span id="pool-stats-name">Pool Statistics</span>
            </h2>
            <div class="grid">
                <div class="card mining-stat">
                    <div class="card-header">
                        <span class="card-title">Active Workers</span>
                        <span class="card-icon">üë•</span>
                    </div>
                    <div class="card-value metric-accent" id="pool-workers">0</div>
                    <div class="card-label">Connected miners</div>
                </div>

                <div class="card mining-stat">
                    <div class="card-header">
                        <span class="card-title">Total Hashrate</span>
                        <span class="card-icon">‚ö°</span>
                    </div>
                    <div class="card-value" id="pool-hashrate">0 H/s</div>
                    <div class="card-label">Combined power</div>
                </div>

                <div class="card mining-stat">
                    <div class="card-header">
                        <span class="card-title">Shares Submitted</span>
                        <span class="card-icon">üìä</span>
                    </div>
                    <div class="card-value" id="pool-shares">0</div>
                    <div class="card-label">Valid work submitted</div>
                </div>

                <div class="card mining-stat">
                    <div class="card-header">
                        <span class="card-title">Blocks Found</span>
                        <span class="card-icon">üéØ</span>
                    </div>
                    <div class="card-value metric-accent" id="pool-blocks">0</div>
                    <div class="card-label">Pool success</div>
                </div>
            </div>
        </div>

        <!-- Farm Mode Section -->
        <div class="wallet-box" id="farm-mode-section" style="display: none;">
            <h2 style="margin-bottom: 1rem; font-size: 1.3rem;">üöú Farm Mode - Rig Management</h2>
            
            <!-- Create New Rig Configuration -->
            <div style="background: rgba(138, 92, 255, 0.08); border: 1px solid rgba(162, 145, 255, 0.3); border-radius: 12px; padding: 1.5rem; margin-bottom: 1.5rem;">
                <h3 style="font-size: 1.1rem; margin-bottom: 1rem; color: var(--accent-purple);">‚ûï Add New Rig</h3>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                    <div>
                        <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                            Rig Name:
                        </label>
                        <input 
                            type="text" 
                            id="new-rig-name" 
                            class="wallet-input" 
                            placeholder="My Mining Rig"
                            maxlength="50"
                        />
                    </div>

                    <div>
                        <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                            Connection Type:
                        </label>
                        <select id="rig-connection-type" class="wallet-input">
                            <option value="local">üè† Local (LAN)</option>
                            <option value="public">üåê Public (Internet)</option>
                        </select>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                    <div>
                        <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                            Wallet Address (optional):
                        </label>
                        <input 
                            type="text" 
                            id="rig-wallet-address" 
                            class="wallet-input" 
                            placeholder="Leave empty to use default"
                        />
                    </div>

                    <div>
                        <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                            CPU Threads (optional):
                        </label>
                        <input 
                            type="number" 
                            id="rig-threads" 
                            class="wallet-input" 
                            placeholder="Auto-detect"
                            min="1"
                        />
                    </div>
                </div>

                <button class="btn btn-primary" onclick="createRigConfig()" style="width: 100%;">
                    üíæ Save Config & Download Bundle
                </button>
            </div>

            <!-- Connected Rigs Stats -->
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin-bottom: 1.5rem;">
                <div style="background: rgba(138, 92, 255, 0.1); border: 1px solid rgba(162, 145, 255, 0.3); border-radius: 8px; padding: 1rem; text-align: center;">
                    <div style="color: var(--text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">TOTAL RIGS</div>
                    <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-purple);" id="farm-total-rigs">0</div>
                </div>
                <div style="background: rgba(0, 255, 136, 0.1); border: 1px solid rgba(0, 255, 136, 0.3); border-radius: 8px; padding: 1rem; text-align: center;">
                    <div style="color: var(--text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">ONLINE</div>
                    <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);" id="farm-online-rigs">0</div>
                </div>
                <div style="background: rgba(0, 212, 255, 0.1); border: 1px solid rgba(0, 212, 255, 0.3); border-radius: 8px; padding: 1rem; text-align: center;">
                    <div style="color: var(--text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">MINING</div>
                    <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-cyan);" id="farm-mining-rigs">0</div>
                </div>
                <div style="background: rgba(0, 212, 255, 0.1); border: 1px solid rgba(0, 212, 255, 0.3); border-radius: 8px; padding: 1rem; text-align: center;">
                    <div style="color: var(--text-secondary); font-size: 0.8rem; margin-bottom: 0.25rem;">TOTAL H/s</div>
                    <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue);" id="farm-total-hashrate">0</div>
                </div>
            </div>

            <!-- Connected Rigs List -->
            <div style="background: rgba(12, 8, 33, 0.5); border: 1px solid var(--border-color); border-radius: 12px; padding: 1.5rem; margin-bottom: 1rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h3 style="font-size: 1.1rem; color: var(--accent-cyan);">üì° Connected Rigs</h3>
                    <button class="btn btn-secondary" onclick="farmRefresh()" style="padding: 0.4rem 1rem; font-size: 0.85rem;">
                        üîÑ Refresh
                    </button>
                </div>
                
                <div id="farm-rigs-list">
                    <div style="text-align: center; padding: 2rem; color: var(--text-secondary);">
                        No rigs connected yet. Create a rig config above and run it on your mining machines.
                    </div>
                </div>
            </div>

            <!-- Bulk Actions -->
            <div style="display: flex; gap: 0.75rem;">
                <button class="btn btn-primary" onclick="farmStartAll()" style="flex: 1;">
                    ‚ñ∂Ô∏è Start All Rigs
                </button>
                <button class="btn btn-secondary" onclick="farmStopAll()" style="flex: 1;">
                    ‚è∏Ô∏è Stop All Rigs
                </button>
            </div>
        </div>

        <!-- Rig Configuration Drawer (hidden by default) -->
        <div id="rig-config-drawer" style="display: none; position: fixed; top: 0; right: 0; width: 480px; height: 100vh; background: linear-gradient(135deg, rgba(12, 8, 33, 0.98), rgba(23, 15, 58, 0.98)); box-shadow: -4px 0 24px rgba(0, 0, 0, 0.8); z-index: 1000; overflow-y: auto; padding: 2rem; border-left: 2px solid var(--border-color);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                <h2 style="font-size: 1.5rem; color: var(--accent-purple);">‚öôÔ∏è Rig Configuration</h2>
                <button onclick="closeRigConfig()" style="background: transparent; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer; padding: 0.25rem 0.5rem;">‚úï</button>
            </div>

            <div id="rig-config-content">
                <div style="text-align: center; padding: 3rem; color: var(--text-secondary);">
                    Select a rig to configure
                </div>
            </div>
        </div>

        <!-- Worker List (shown when hosting pool) -->
        <div class="block-ticker" id="worker-list" style="display: none;">
            <h2 style="margin-bottom: 1rem; font-size: 1.3rem;">üë∑ Active Workers</h2>
            <div style="overflow-x: auto;">
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="border-bottom: 2px solid var(--border-color);">
                            <th style="text-align: left; padding: 0.75rem; color: var(--text-secondary);">Worker ID</th>
                            <th style="text-align: left; padding: 0.75rem; color: var(--text-secondary);">Wallet</th>
                            <th style="text-align: right; padding: 0.75rem; color: var(--text-secondary);">Shares</th>
                            <th style="text-align: right; padding: 0.75rem; color: var(--text-secondary);">Hashrate</th>
                            <th style="text-align: right; padding: 0.75rem; color: var(--text-secondary);">Est. Payout</th>
                        </tr>
                    </thead>
                    <tbody id="worker-table-body">
                        <tr>
                            <td colspan="5" style="text-align: center; padding: 2rem; color: var(--text-secondary);">
                                No workers connected
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Miner Intelligence Section -->
        <div class="wallet-box" style="background: radial-gradient(circle at top, rgba(138, 92, 255, 0.12), rgba(12, 8, 33, 0.85)); border: 1px solid rgba(162, 145, 255, 0.4);">
            <h2 style="margin-bottom: 1.5rem; font-size: 1.3rem;">üß† Miner Intelligence</h2>
            
            <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));">
                <!-- CPU Information Card -->
                <div class="card" style="background: rgba(0, 212, 255, 0.08); border: 1px solid rgba(0, 212, 255, 0.3);">
                    <div class="card-header">
                        <span class="card-title">CPU DETECTION</span>
                        <span class="card-icon">üíª</span>
                    </div>
                    <div style="margin-top: 1rem;">
                        <div id="cpu-name" style="font-size: 0.9rem; color: var(--accent-cyan); font-weight: 600; margin-bottom: 0.5rem;">
                            Loading...
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 0.75rem; padding: 0.5rem; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                            <div>
                                <div style="font-size: 0.75rem; color: var(--text-secondary);">Cores</div>
                                <div id="cpu-cores" style="font-size: 1.1rem; color: var(--accent-cyan); font-weight: 600;">--</div>
                            </div>
                            <div>
                                <div style="font-size: 0.75rem; color: var(--text-secondary);">Threads</div>
                                <div id="cpu-threads" style="font-size: 1.1rem; color: var(--accent-cyan); font-weight: 600;">--</div>
                            </div>
                        </div>
                        <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-secondary);">
                            Bucket: <span id="cpu-bucket" style="color: var(--accent-cyan);">--</span>
                        </div>
                    </div>
                </div>

                <!-- P2P Tuning Hints Card -->
                <div class="card" style="background: rgba(138, 92, 255, 0.08); border: 1px solid rgba(162, 145, 255, 0.3);">
                    <div class="card-header">
                        <span class="card-title">P2P HINTS</span>
                        <span class="card-icon">üîÑ</span>
                    </div>
                    <div style="margin-top: 1rem;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                            <div style="padding: 0.5rem; background: rgba(0, 0, 0, 0.3); border-radius: 6px; text-align: center;">
                                <div style="font-size: 0.75rem; color: var(--text-secondary);">Pending</div>
                                <div id="hints-pending" style="font-size: 1.3rem; color: #fbbf24; font-weight: 600;">0</div>
                            </div>
                            <div style="padding: 0.5rem; background: rgba(0, 0, 0, 0.3); border-radius: 6px; text-align: center;">
                                <div style="font-size: 0.75rem; color: var(--text-secondary);">Testing</div>
                                <div id="hints-testing" style="font-size: 1.3rem; color: var(--accent-cyan); font-weight: 600;">0</div>
                            </div>
                            <div style="padding: 0.5rem; background: rgba(0, 0, 0, 0.3); border-radius: 6px; text-align: center;">
                                <div style="font-size: 0.75rem; color: var(--text-secondary);">Verified</div>
                                <div id="hints-verified" style="font-size: 1.3rem; color: var(--accent-green); font-weight: 600;">0</div>
                            </div>
                            <div style="padding: 0.5rem; background: rgba(0, 0, 0, 0.3); border-radius: 6px; text-align: center;">
                                <div style="font-size: 0.75rem; color: var(--text-secondary);">Rejected</div>
                                <div id="hints-rejected" style="font-size: 1.3rem; color: #ef4444; font-weight: 600;">0</div>
                            </div>
                        </div>
                        <div style="margin-top: 0.75rem; font-size: 0.8rem; color: var(--text-secondary); text-align: center;">
                            <span id="hints-status" style="color: var(--accent-purple);">System Active</span>
                        </div>
                    </div>
                </div>

                <!-- Thermal Status Card -->
                <div class="card" style="background: rgba(255, 136, 0, 0.08); border: 1px solid rgba(255, 136, 0, 0.3);">
                    <div class="card-header">
                        <span class="card-title">THERMAL</span>
                        <span class="card-icon">üå°Ô∏è</span>
                    </div>
                    <div style="margin-top: 1rem;">
                        <div style="text-align: center; padding: 0.75rem; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                            <div id="thermal-temp" style="font-size: 2rem; color: var(--accent-green); font-weight: 700;">--¬∞C</div>
                            <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem;">Current Temperature</div>
                        </div>
                        <div style="margin-top: 0.75rem; display: flex; justify-content: space-between; font-size: 0.8rem;">
                            <span style="color: var(--text-secondary);">Soft Limit:</span>
                            <span id="thermal-soft" style="color: #fbbf24;">80¬∞C</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 0.8rem; margin-top: 0.25rem;">
                            <span style="color: var(--text-secondary);">Hard Limit:</span>
                            <span id="thermal-hard" style="color: #ef4444;">90¬∞C</span>
                        </div>
                        <div id="thermal-throttled" style="display: none; margin-top: 0.5rem; padding: 0.5rem; background: rgba(239, 68, 68, 0.2); border: 1px solid #ef4444; border-radius: 6px; font-size: 0.8rem; color: #ef4444; text-align: center;">
                            ‚ö†Ô∏è Throttled
                        </div>
                    </div>
                </div>

                <!-- Power Status Card -->
                <div class="card" style="background: rgba(0, 255, 136, 0.08); border: 1px solid rgba(0, 255, 136, 0.3);">
                    <div class="card-header">
                        <span class="card-title">POWER</span>
                        <span class="card-icon">üîã</span>
                    </div>
                    <div style="margin-top: 1rem;">
                        <div style="text-align: center; padding: 0.75rem; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                            <div id="power-status" style="font-size: 1.5rem; font-weight: 600; color: var(--accent-green);">AC Power</div>
                            <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem;">Current Source</div>
                        </div>
                        <div id="battery-cap" style="display: none; margin-top: 0.75rem; padding: 0.5rem; background: rgba(251, 191, 36, 0.2); border: 1px solid #fbbf24; border-radius: 6px; font-size: 0.8rem; color: #fbbf24; text-align: center;">
                            ‚ö° Battery Cap Active
                        </div>
                    </div>
                </div>

                <!-- NUMA Status Card -->
                <div class="card" style="background: rgba(162, 145, 255, 0.08); border: 1px solid rgba(162, 145, 255, 0.3);">
                    <div class="card-header">
                        <span class="card-title">NUMA</span>
                        <span class="card-icon">üéØ</span>
                    </div>
                    <div style="margin-top: 1rem;">
                        <div style="text-align: center; padding: 0.75rem; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                            <div id="numa-nodes" style="font-size: 2rem; color: var(--accent-purple); font-weight: 700;">1</div>
                            <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem;">NUMA Nodes Detected</div>
                        </div>
                        <div style="margin-top: 0.75rem; text-align: center; font-size: 0.8rem;">
                            <span id="numa-pinning" style="color: var(--text-secondary);">Pinning: <span style="color: var(--accent-purple);">Disabled</span></span>
                        </div>
                    </div>
                </div>

                <!-- Version Info Card -->
                <div class="card" style="background: rgba(0, 212, 255, 0.08); border: 1px solid rgba(0, 212, 255, 0.3);">
                    <div class="card-header">
                        <span class="card-title">VERSION</span>
                        <span class="card-icon">‚ÑπÔ∏è</span>
                    </div>
                    <div style="margin-top: 1rem;">
                        <div style="text-align: center; padding: 0.75rem; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                            <div id="intelligence-version" style="font-size: 1.5rem; color: var(--accent-cyan); font-weight: 700;">v2.7.0</div>
                            <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem;">Miner Intelligence</div>
                        </div>
                        <div style="margin-top: 0.75rem; text-align: center; font-size: 0.75rem; color: var(--text-secondary);">
                            P2P Hardening + Tuning Hints
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Hashrate Chart -->
        <div class="chart-container">
            <h2 style="margin-bottom: 1rem; font-size: 1.3rem;">üìä Hashrate History</h2>
            <canvas id="hashrateChart"></canvas>
        </div>

        <!-- Recent Blocks Ticker -->
        <div class="block-ticker">
            <h2 style="margin-bottom: 1rem; font-size: 1.3rem;">üéØ Recent Blocks</h2>
            <div id="block-list">
                <div style="text-align: center; color: var(--text-secondary); padding: 2rem;">
                    Mining blocks...
                </div>
            </div>
        </div>

        <!-- Peer Geo Map - 3D Spinning Globe with Animated Space -->
        <div class="geo-map" id="geo-map">
            <div class="globe-title">üåç Network Peers Worldwide</div>
            <div class="globe-stats" id="globe-stats">0 peers</div>
            <div id="peer-map">
                <!-- Animated Milky Way Background -->
                <div class="milky-way"></div>
                <!-- Shooting Stars (will be added dynamically) -->
            </div>
        </div>

        <div class="actions">
            <button class="btn btn-secondary" id="refresh-btn">
                <span>üîÑ</span>
                <span>Refresh</span>
            </button>
            <button class="btn btn-secondary" id="metrics-btn">
                <span>üìä</span>
                <span>Metrics</span>
            </button>
            <button class="btn btn-secondary" id="network-mood-btn">
                <span>üåê</span>
                <span>Network Mood</span>
            </button>
            <button class="btn btn-secondary" id="sound-btn">
                <span>üîä</span>
                <span>Sound: ON</span>
            </button>
        </div>

        <!-- Activity Log with Filters -->
        <div class="log-container">
            <div class="log-header">
                <span class="log-title">Activity Log</span>
                <div style="display: flex; gap: 0.5rem;">
                    <button class="btn btn-secondary" style="padding: 0.5rem 1rem; font-size: 0.85rem;" id="freeze-scroll-btn">‚ùÑÔ∏è Freeze</button>
                    <button class="btn btn-secondary" style="padding: 0.5rem 1rem; font-size: 0.85rem;" id="clear-log-btn">Clear</button>
                </div>
            </div>
            <div class="log-filters">
                <button class="filter-chip active" data-filter="all">All</button>
                <button class="filter-chip" data-filter="info">‚ÑπÔ∏è Info</button>
                <button class="filter-chip" data-filter="success">‚úÖ Success</button>
                <button class="filter-chip" data-filter="error">‚ùå Error</button>
                <input type="text" class="search-box" id="log-search" placeholder="üîç Search logs...">
            </div>
            <div class="log-content" id="log"></div>
        </div>

        <!-- Metrics Overlay -->
        <div class="overlay" id="metrics-overlay">
            <div class="overlay-content">
                <button class="close-btn" id="close-metrics">√ó</button>
                <h2 style="margin-bottom: 2rem; font-size: 2rem;">üìä Detailed Metrics</h2>
                
                <div class="grid">
                    <div class="card">
                        <div class="card-header">
                            <span class="card-title">Total Supply</span>
                            <span class="card-icon">üí∞</span>
                        </div>
                        <div class="card-value" id="metrics-supply">--</div>
                        <div class="card-label">Circulating tokens</div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <span class="card-title">Vault Balance</span>
                            <span class="card-icon">üè¶</span>
                        </div>
                        <div class="card-value" id="metrics-vault">--</div>
                        <div class="card-label">Locked in vault</div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <span class="card-title">Treasury</span>
                            <span class="card-icon">üèõÔ∏è</span>
                        </div>
                        <div class="card-value" id="metrics-treasury">--</div>
                        <div class="card-label">Treasury funds</div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <span class="card-title">Burned</span>
                            <span class="card-icon">üî•</span>
                        </div>
                        <div class="card-value" id="metrics-burned">--</div>
                        <div class="card-label">Tokens burned</div>
                    </div>
                </div>

                <button class="btn btn-primary" id="copy-json-btn" style="margin-top: 2rem; width: 100%;">
                    üìã Copy Full JSON
                </button>
            </div>
        </div>

        <footer class="footer">
            <p>Vision Node v1.1.0 - Production Ready</p>
            <p style="margin-top: 0.5rem;">Built with ü¶Ä Rust | üîó Blockchain for Vision World</p>
        </footer>
    </div>

    <script>
        const API_BASE = '/api';
        const LAND_DECIMALS = 9; // LAND token has 9 decimals
        const LAND_DIVISOR = 1_000_000_000; // 10^9
        
        // Helper function to format LAND tokens from smallest units
        function formatLAND(smallestUnits, includeLabel = true) {
            const land = parseInt(smallestUnits) / LAND_DIVISOR;
            const formatted = land.toLocaleString(undefined, {
                minimumFractionDigits: 0,
                maximumFractionDigits: 2
            });
            return includeLabel ? `${formatted} LAND` : formatted;
        }
        
        let isConnected = false;
        let hashrateChart = null;
        let peerChart = null;
        let recentBlocks = [];
        let peerHistory = [];
        let hashrateData = {
            labels: [],
            blocks: [],
            timestamps: []
        };
        let allPeers = [];
        let displayedPeerCount = 0;
        const PEERS_PER_PAGE = 50;
        let currentWallet = null;  // Will be loaded from backend (persisted in database)
        let firstStatusFetched = false;
        
        // WebSocket
        let ws = null;
        let wsReconnectAttempts = 0;
        const WS_MAX_RECONNECT = 5;
        
        // Sound
        let soundEnabled = localStorage.getItem('soundEnabled') !== 'false';
        const blockMinedSound = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBS+I0fPTgjMGHm7A7+OZSA0PVqzn77RiGwU7k9n0z3kqBSJ1xe/glUcLElyx6+2nUxEKRp3f87toHgIuiM/z1YU1BhxrvO7jmEgNDlOq5O+0YhoEO5PZ9M95KgUkdcXv4ZVHFA=='); 
        
        // Activity Log
        let logFilter = 'all';
        let logSearchTerm = '';
        let freezeScroll = false;
        let allLogs = [];
        
        // Rig Health
        let rigHealthData = null;
        let geoMap = null;
        let metricsData = {};
        let globeAnimationId = null;

        // ========================================
        // ANCHOR MODE INTEGRATION
        // ========================================
        async function fetchConstellationStatus() {
            try {
                const response = await fetch('/constellation/status', { cache: 'no-store' });
                if (!response.ok) return null;
                return await response.json();
            } catch (e) {
                console.error('Failed to fetch constellation status:', e);
                return null;
            }
        }

        async function updateAnchorModeButton() {
            const container = document.getElementById('anchorModeContainer');
            if (!container) return;

            const status = await fetchConstellationStatus();
            if (!status) {
                container.innerHTML = '<p style="color: #666; font-size: 0.9rem;">P2P status unavailable</p>';
                return;
            }

            const isAnchor = status.is_anchor || false;
            const isReachable = status.public_reachable || false;
            
            let modeText = '';
            let buttonColor = '';
            let icon = '';
            
            if (isAnchor) {
                if (isReachable) {
                    modeText = 'Anchor Mode ‚úì';
                    buttonColor = '#10b981';
                    icon = '‚öì';
                } else {
                    modeText = 'Anchor (Unreachable)';
                    buttonColor = '#f59e0b';
                    icon = '‚öì';
                }
            } else {
                modeText = 'Leaf Mode';
                buttonColor = '#6b7280';
                icon = 'üçÉ';
            }

            container.innerHTML = `
                <button 
                    class="btn-primary" 
                    style="background: ${buttonColor}; padding: 0.5rem 1rem; font-size: 0.9rem; cursor: pointer;"
                    onclick="showAnchorInstructions(${isAnchor})"
                >
                    ${icon} ${modeText}
                </button>
            `;
        }

        function showAnchorInstructions(isCurrentlyAnchor) {
            if (isCurrentlyAnchor) {
                alert(
                    'üçÉ Switch to Leaf Mode:\n\n' +
                    '1. Stop your Guardian node\n' +
                    '2. Remove P2P_IS_ANCHOR from your .env file\n' +
                    '3. Restart your Guardian node\n\n' +
                    'Leaf mode is suitable for home networks or nodes behind NAT/firewalls.'
                );
            } else {
                alert(
                    '‚öì Enable Anchor Mode:\n\n' +
                    '1. Stop your Guardian node\n' +
                    '2. Add P2P_IS_ANCHOR=true to your .env file\n' +
                    '3. Ensure port 7077 is open and reachable from the internet\n' +
                    '4. Restart your Guardian node\n\n' +
                    'Anchor mode requires a public IP and open port 7077 for incoming connections.'
                );
            }
        }

        // Update anchor button on load and every 10 seconds
        updateAnchorModeButton();
        setInterval(updateAnchorModeButton, 10000);

        // ========================================
        // MINER API INTEGRATION
        // ========================================
        const MINER_API_BASE = '/api';
        let minerConfig = { threads: 0, enabled: false, max_threads: 1 };
        let minerPollingInterval = null;

        // API helper functions
        async function getMinerConfig() {
            try {
                const r = await fetch(`${MINER_API_BASE}/miner/status`, { cache: 'no-store' });
                if (!r.ok) {
                    console.error(`Miner API returned ${r.status}: ${r.statusText}`);
                    throw new Error(`HTTP ${r.status}`);
                }
                const status = await r.json();
                console.log('Miner status received:', status);
                // Convert status response to config format
                return {
                    threads: status.threads || 0,
                    enabled: status.enabled || false,
                    max_threads: status.max_threads || navigator.hardwareConcurrency || 8
                };
            } catch (e) {
                console.error('Failed to get miner config:', e);
                return null;
            }
        }

        async function setMinerThreads(threads) {
            try {
                const r = await fetch(`${MINER_API_BASE}/miner/threads`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ threads })
                });
                if (!r.ok) throw new Error(`HTTP ${r.status}`);
                return await r.json();
            } catch (e) {
                console.error('Failed to set miner threads:', e);
                return null;
            }
        }

        async function saveMinerConfig() {
            try {
                // Collect form values
                const miningProfile = document.getElementById('miningProfile').value;
                const miningThreadsRaw = document.getElementById('miningThreads').value;
                const simdBatchSizeRaw = document.getElementById('simdBatchSize').value;

                // Convert to proper types or null
                const miningThreads = 
                    miningThreadsRaw === '' || miningThreadsRaw === '0' 
                        ? null 
                        : parseInt(miningThreadsRaw, 10);

                const simdBatchSize = 
                    simdBatchSizeRaw === '' 
                        ? null 
                        : parseInt(simdBatchSizeRaw, 10);

                const payload = {
                    mining_profile: miningProfile,
                    mining_threads: miningThreads,
                    simd_batch_size: simdBatchSize
                };

                console.log('Saving miner config:', payload);

                const r = await fetch(`${MINER_API_BASE}/miner/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!r.ok) {
                    console.error(`Failed to save miner config: HTTP ${r.status}`);
                    return false;
                }

                const result = await r.json();
                console.log('Miner config saved:', result);
                return true;
            } catch (e) {
                console.error('Failed to save miner config:', e);
                return false;
            }
        }

        async function getMinerSpeed() {
            try {
                // Use miner status endpoint which includes hashrate and recent blocks
                const r = await fetch(`${MINER_API_BASE}/miner/status`, { cache: 'no-store' });
                if (!r.ok) {
                    console.warn(`Miner speed API returned ${r.status}`);
                    return null;
                }
                const status = await r.json();
                
                // Update recent blocks if available
                if (status.recent_blocks && Array.isArray(status.recent_blocks)) {
                    recentBlocks = status.recent_blocks;
                    renderBlockList();
                }
                
                return {
                    current_hashrate: status.hashrate || 0,
                    average_hashrate: status.average_hashrate || 0,
                    history: status.history || []
                };
            } catch (e) {
                console.error('Failed to get miner speed:', e);
                return null;
            }
        }

        async function getMinerStats() {
            try {
                const r = await fetch(`${MINER_API_BASE}/miner/status`, { cache: 'no-store' });
                if (!r.ok) {
                    console.warn(`Miner stats API returned ${r.status}`);
                    return null;
                }
                const stats = await r.json();
                console.log('Miner stats:', stats);
                return stats;
            } catch (e) {
                console.error('Failed to get miner stats:', e);
                return null;
            }
        }

        // Fetch miner intelligence (CPU, hints, thermal/power/NUMA)
        async function getMinerIntelligence() {
            try {
                const r = await fetch(`${MINER_API_BASE}/miner/intelligence`, { cache: 'no-store' });
                if (!r.ok) {
                    console.warn(`Miner intelligence API returned ${r.status}`);
                    return null;
                }
                const intelligence = await r.json();
                console.log('Miner intelligence:', intelligence);
                return intelligence;
            } catch (e) {
                console.error('Failed to get miner intelligence:', e);
                return null;
            }
        }

        // Update miner intelligence UI
        function updateMinerIntelligence(data) {
            if (!data) return;
            
            // CPU Information
            if (data.cpu) {
                document.getElementById('cpu-name').textContent = data.cpu.name || 'Unknown CPU';
                document.getElementById('cpu-cores').textContent = data.cpu.physical_cores || '--';
                document.getElementById('cpu-threads').textContent = data.cpu.logical_threads || '--';
                document.getElementById('cpu-bucket').textContent = data.cpu.bucket || '--';
            }
            
            // P2P Hints
            if (data.p2p_hints) {
                document.getElementById('hints-pending').textContent = data.p2p_hints.pending || 0;
                document.getElementById('hints-testing').textContent = data.p2p_hints.testing || 0;
                document.getElementById('hints-verified').textContent = data.p2p_hints.verified || 0;
                document.getElementById('hints-rejected').textContent = data.p2p_hints.rejected || 0;
                document.getElementById('hints-status').textContent = data.p2p_hints.enabled ? 'System Active' : 'Disabled';
            }
            
            // Thermal Status
            if (data.thermal) {
                const tempEl = document.getElementById('thermal-temp');
                const throttledEl = document.getElementById('thermal-throttled');
                
                if (data.thermal.current_temp !== null && data.thermal.current_temp !== undefined) {
                    tempEl.textContent = data.thermal.current_temp + '¬∞C';
                    
                    // Color based on temperature
                    if (data.thermal.current_temp >= data.thermal.hard_limit) {
                        tempEl.style.color = '#ef4444'; // Red
                    } else if (data.thermal.current_temp >= data.thermal.soft_limit) {
                        tempEl.style.color = '#fbbf24'; // Yellow
                    } else {
                        tempEl.style.color = 'var(--accent-green)';
                    }
                } else {
                    tempEl.textContent = '--¬∞C';
                    tempEl.style.color = 'var(--text-secondary)';
                }
                
                document.getElementById('thermal-soft').textContent = (data.thermal.soft_limit || 80) + '¬∞C';
                document.getElementById('thermal-hard').textContent = (data.thermal.hard_limit || 90) + '¬∞C';
                
                if (data.thermal.throttled) {
                    throttledEl.style.display = 'block';
                } else {
                    throttledEl.style.display = 'none';
                }
            }
            
            // Power Status
            if (data.power) {
                const powerStatus = document.getElementById('power-status');
                const batteryCap = document.getElementById('battery-cap');
                
                if (data.power.on_battery) {
                    powerStatus.textContent = 'üîã Battery';
                    powerStatus.style.color = '#fbbf24';
                } else {
                    powerStatus.textContent = '‚ö° AC Power';
                    powerStatus.style.color = 'var(--accent-green)';
                }
                
                if (data.power.battery_cap_enabled) {
                    batteryCap.style.display = 'block';
                } else {
                    batteryCap.style.display = 'none';
                }
            }
            
            // NUMA Status
            if (data.numa) {
                document.getElementById('numa-nodes').textContent = data.numa.nodes_detected || 1;
                const pinningText = data.numa.using_pinning ? 'Enabled' : 'Disabled';
                document.getElementById('numa-pinning').innerHTML = `Pinning: <span style="color: var(--accent-purple);">${pinningText}</span>`;
            }
            
            // Version
            if (data.version) {
                document.getElementById('intelligence-version').textContent = 'v' + data.version;
            }
        }

        // Initialize miner controls
        async function initMinerControls() {
            const config = await getMinerConfig();
            if (!config) {
                console.warn('Miner API not available');
                return;
            }

            minerConfig = config;
            
            // Setup thread slider
            const slider = document.getElementById('thread-slider');
            const applyBtn = document.getElementById('apply-threads-btn');
            
            slider.max = config.max_threads;
            slider.value = config.threads;
            slider.disabled = false;
            applyBtn.disabled = false;

            // Load mining performance tuning fields
            if (config.mining_profile !== undefined && config.mining_profile !== null) {
                document.getElementById('miningProfile').value = config.mining_profile;
            } else {
                document.getElementById('miningProfile').value = 'balanced';
            }

            if (config.mining_threads !== undefined && config.mining_threads !== null) {
                document.getElementById('miningThreads').value = config.mining_threads || '';
            } else {
                document.getElementById('miningThreads').value = '';
            }

            if (config.simd_batch_size !== undefined && config.simd_batch_size !== null) {
                document.getElementById('simdBatchSize').value = config.simd_batch_size;
            } else {
                document.getElementById('simdBatchSize').value = 4;
            }

            updateThreadDisplay();

            // Event listeners
            slider.addEventListener('input', () => {
                document.getElementById('current-threads').textContent = slider.value;
            });

            applyBtn.addEventListener('click', async () => {
                const newThreads = parseInt(slider.value);
                
                // Prevent starting mining with apply button (only allow adjusting if already mining)
                if (minerConfig.threads === 0 && newThreads > 0) {
                    showToast('Use Start Mining button to begin mining', 'warning');
                    slider.value = 0;
                    document.getElementById('current-threads').textContent = '0';
                    return;
                }
                
                applyBtn.disabled = true;
                applyBtn.innerHTML = '<span>‚è≥</span><span>Applying...</span>';
                
                // Save performance tuning config first
                const configSaved = await saveMinerConfig();
                if (!configSaved) {
                    showToast('Warning: Performance settings may not have saved', 'warning');
                }
                
                // Then update thread count
                const result = await setMinerThreads(newThreads);
                if (result) {
                    minerConfig.threads = newThreads;
                    updateThreadDisplay();
                    showToast(`Mining configuration updated (threads: ${newThreads})`, 'success');
                } else {
                    showToast('Failed to update threads', 'error');
                }
                
                applyBtn.disabled = false;
                applyBtn.innerHTML = '<span>‚úÖ</span><span>Apply</span>';
            });

            // Start polling
            startMinerPolling();
        }

        function updateThreadDisplay() {
            document.getElementById('current-threads').textContent = minerConfig.threads;
            document.getElementById('max-threads').textContent = minerConfig.max_threads;
            
            const statusEl = document.getElementById('mining-status');
            if (minerConfig.threads > 0) {
                statusEl.innerHTML = 'Status: <strong style="color: var(--accent-green);">Mining ‚ö°</strong>';
            } else {
                statusEl.innerHTML = 'Status: <strong style="color: var(--text-secondary);">Idle</strong>';
            }
        }

        function startMinerPolling() {
            if (minerPollingInterval) clearInterval(minerPollingInterval);
            
            // Poll speed every 1 second
            minerPollingInterval = setInterval(async () => {
                const speed = await getMinerSpeed();
                if (speed) {
                    updateMinerDisplay(speed);
                }
            }, 1000);

            // Also poll stats every 5 seconds
            setInterval(async () => {
                const stats = await getMinerStats();
                if (stats) {
                    updateMiningStats(stats);
                }
            }, 5000);
        }

        function updateMinerDisplay(speed) {
            // Update current hashrate
            const hashrate = speed.current_hashrate || 0;
            document.getElementById('current-hashrate').textContent = formatHashrate(hashrate);

            // Update hashrate chart
            if (hashrateChart && speed.history) {
                const history = speed.history.slice(-60); // Last 60 seconds
                const labels = history.map((_, i) => `${i}s`);
                const data = history.map(h => h / 1000); // Convert to kH/s
                
                hashrateChart.data.labels = labels;
                hashrateChart.data.datasets[0].data = data;
                hashrateChart.data.datasets[0].label = 'Hashrate (kH/s)';
                hashrateChart.update('none'); // No animation for smooth updates
            }
        }

        function updateMiningStats(stats) {
            if (!stats) return;
            
            document.getElementById('total-mined').textContent = stats.blocks_found || 0;
            
            const successRate = stats.blocks_found > 0 
                ? ((stats.blocks_accepted / stats.blocks_found) * 100).toFixed(1)
                : '100';
            document.getElementById('success-rate').textContent = `${successRate}%`;
            
            // Use average_block_time from API (in seconds)
            if (stats.average_block_time) {
                const avgTimeMs = stats.average_block_time * 1000;
                document.getElementById('avg-time').textContent = formatTime(avgTimeMs);
            } else if (stats.average_solve_time_ms) {
                document.getElementById('avg-time').textContent = formatTime(stats.average_solve_time_ms);
            }
        }

        function formatHashrate(hashrate) {
            if (hashrate >= 1_000_000) {
                return `${(hashrate / 1_000_000).toFixed(2)} MH/s`;
            } else if (hashrate >= 1_000) {
                return `${(hashrate / 1_000).toFixed(2)} kH/s`;
            } else {
                return `${hashrate.toFixed(0)} H/s`;
            }
        }

        function formatTime(ms) {
            if (ms >= 1000) {
                return `${(ms / 1000).toFixed(2)}s`;
            } else {
                return `${ms.toFixed(0)}ms`;
            }
        }

        function showToast(message, type = 'info') {
            // Simple toast notification (you can enhance this)
            console.log(`[${type.toUpperCase()}] ${message}`);
            // Optional: Add visual toast notification here
        }

        // ========================================
        // END MINER API INTEGRATION
        // ========================================

        // Initialize charts
        function initCharts() {
            // Hashrate chart
            const hashrateCtx = document.getElementById('hashrateChart').getContext('2d');
            hashrateChart = new Chart(hashrateCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Blocks Mined',
                        data: [],
                        borderColor: '#00d4ff',
                        backgroundColor: 'rgba(0, 212, 255, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, labels: { color: '#8892b0' } }
                    },
                    scales: {
                        y: { 
                            beginAtZero: true,
                            ticks: { color: '#8892b0' },
                            grid: { color: '#1e2a5a' }
                        },
                        x: { 
                            ticks: { color: '#8892b0' },
                            grid: { color: '#1e2a5a' }
                        }
                    }
                }
            });

            // Peer sparkline
            const peerSparklineEl = document.getElementById('peerSparkline');
            if (peerSparklineEl) {
                const peerCtx = peerSparklineEl.getContext('2d');
                peerChart = new Chart(peerCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Peers',
                        data: [],
                        borderColor: '#00ff88',
                        backgroundColor: 'rgba(0, 255, 136, 0.1)',
                        tension: 0.4,
                        fill: true,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { display: false },
                        x: { display: false }
                    }
                }
            });
            }
        }

        function updateHashrateChart(height) {
            const now = new Date().toLocaleTimeString();
            hashrateData.labels.push(now);
            hashrateData.blocks.push(height);
            hashrateData.timestamps.push(Date.now());

            // Keep last 20 data points
            if (hashrateData.labels.length > 20) {
                hashrateData.labels.shift();
                hashrateData.blocks.shift();
                hashrateData.timestamps.shift();
            }

            hashrateChart.data.labels = hashrateData.labels;
            hashrateChart.data.datasets[0].data = hashrateData.blocks;
            hashrateChart.update('none');
        }

        function updatePeerChart(peerCount) {
            peerHistory.push(peerCount);
            if (peerHistory.length > 60) peerHistory.shift();

            const peak = Math.max(...peerHistory, 0);
            document.getElementById('peer-count').textContent = peerCount;
            document.getElementById('peer-peak').textContent = peak;

            peerChart.data.labels = peerHistory.map((_, i) => i);
            peerChart.data.datasets[0].data = peerHistory;
            peerChart.update('none');
        }

        async function fetchRecentBlocks() {
            // Recent blocks are now included in miner status, no need to fetch separately
            // They're updated in the main status polling loop
        }

        function renderBlockList() {
            const listEl = document.getElementById('block-list');
            if (recentBlocks.length === 0) {
                listEl.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 2rem;">No blocks yet</div>';
                return;
            }

            listEl.innerHTML = recentBlocks.map(block => {
                const timeAgo = block.timestamp ? getTimeAgo(block.timestamp) : 'just now';
                const shortHash = block.hash ? block.hash.substring(0, 12) + '...' : 'N/A';
                
                return `
                    <div class="block-item">
                        <div>
                            <span class="block-height">#${block.height}</span>
                            <span class="block-miner" onclick="copyToClipboard('${block.hash}')" title="${block.hash}">
                                ${shortHash}
                            </span>
                        </div>
                        <div class="block-reward">${block.txs || 0} txs ‚Ä¢ ${timeAgo}</div>
                    </div>
                `;
            }).join('');
        }
        
        function getTimeAgo(timestamp) {
            const seconds = Math.floor(Date.now() / 1000 - timestamp);
            if (seconds < 60) return `${seconds}s ago`;
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                log(`üìã Copied: ${text}`, 'success');
            });
        }

        async function fetchPeers() {
            try {
                // Fetch real constellation peers
                const response = await fetch('/api/peers');
                
                // Check if response is OK and is JSON
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    throw new Error('Not JSON response');
                }
                
                const data = await response.json();
                // data format: { active: N, inbound: N, outbound: N, peers: [{vnode_tag, addr, direction}] }
                
                // Convert to display format
                allPeers = data.peers || [];
                
                // Update peer count in dashboard
                const peerCountEl = document.getElementById('peers');
                if (peerCountEl) {
                    peerCountEl.textContent = data.active || 0;
                }
                
                displayedPeerCount = 0;
                renderPeerList();
                updateGlobe(); // Update globe with peer locations
                
                log(`‚úÖ Loaded ${allPeers.length} constellation peers (${data.inbound || 0} inbound, ${data.outbound || 0} outbound)`);
            } catch (error) {
                // Silent fail for 404 - endpoint doesn't exist yet or no peers connected
                if (!error.message.includes('404')) {
                    console.warn('Peer fetch:', error.message);
                }
                
                // Use empty list if error
                allPeers = [];
                
                // Update peer count to 0
                const peerCountEl = document.getElementById('peers');
                if (peerCountEl) {
                    peerCountEl.textContent = '0';
                }
                
                displayedPeerCount = 0;
                renderPeerList();
                updateGlobe();
            }
        }

        function generateMockPeers(count = 8) {
            // Generate mock peer addresses for demo
            const mockPeers = [];
            const cities = [
                'New York', 'London', 'Tokyo', 'Sydney', 
                'Mumbai', 'S√£o Paulo', 'Berlin', 'Singapore',
                'Toronto', 'Paris', 'Seoul', 'Dubai'
            ];
            
            for (let i = 0; i < Math.min(count, cities.length); i++) {
                mockPeers.push(`/ip4/127.0.0.1/tcp/${7000 + i}/p2p/vision-${cities[i]}`);
            }
            
            return mockPeers;
        }

        function updateGlobe() {
            if (!geoMap || allPeers.length === 0) {
                // Clear globe if no peers
                if (geoMap) {
                    geoMap.pointsData([]);
                    document.getElementById('globe-stats').textContent = '0 peers online';
                }
                return;
            }
            
            const peerLocations = allPeers.map((peer, idx) => {
                // Generate consistent location based on IP address hash
                // For real deployment, you'd use a GeoIP database
                const addrStr = peer.addr || peer.vnode_tag || `peer-${idx}`;
                const hash = addrStr.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                
                // Generate pseudo-random but consistent coordinates
                const lat = ((hash % 180) - 90) + (Math.sin(idx) * 20);
                const lng = ((hash * 7) % 360) - 180;
                
                // Color based on direction: green for inbound, blue for outbound
                const color = peer.direction === 'inbound' ? '#4ade80' : '#60a5fa';
                
                return {
                    lat: lat,
                    lng: lng,
                    size: 0.7 + Math.random() * 0.3,
                    color: color,
                    peer: peer.vnode_tag || peer.addr,
                    direction: peer.direction || 'unknown'
                };
            });

            // Update globe with colored dots (green = inbound, blue = outbound)
            geoMap.pointsData(peerLocations)
                .pointLat('lat')
                .pointLng('lng')
                .pointColor(d => d.color)
                .pointAltitude(0.01)
                .pointRadius(d => d.size)
                .pointLabel(d => `${d.peer} (${d.direction})`)
                .pointsMerge(false);
            
            // Update stats
            const inboundCount = allPeers.filter(p => p.direction === 'inbound').length;
            const outboundCount = allPeers.filter(p => p.direction === 'outbound').length;
            document.getElementById('globe-stats').textContent = 
                `${allPeers.length} peers online (${inboundCount} in, ${outboundCount} out)`;
        }

        function renderPeerList() {
            const listEl = document.getElementById('peer-list');
            const loadMoreBtn = document.getElementById('load-more-peers');
            
            // Elements removed from UI, skip rendering
            if (!listEl) return;
            
            if (allPeers.length === 0) {
                listEl.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 2rem;">No constellation peers connected</div>';
                if (loadMoreBtn) loadMoreBtn.style.display = 'none';
                const peerShowing = document.getElementById('peer-showing');
                const peerTotal = document.getElementById('peer-total');
                if (peerShowing) peerShowing.textContent = '0';
                if (peerTotal) peerTotal.textContent = '0';
                return;
            }

            const toShow = Math.min(displayedPeerCount + PEERS_PER_PAGE, allPeers.length);
            const peersToDisplay = allPeers.slice(0, toShow);
            
            // Create table-style layout for peer details
            listEl.innerHTML = `
                <table style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
                    <thead>
                        <tr style="border-bottom: 1px solid var(--border-color); text-align: left;">
                            <th style="padding: 0.75rem; color: var(--text-secondary); font-size: 0.85rem;">#</th>
                            <th style="padding: 0.75rem; color: var(--text-secondary); font-size: 0.85rem;">VNode Tag</th>
                            <th style="padding: 0.75rem; color: var(--text-secondary); font-size: 0.85rem;">Address</th>
                            <th style="padding: 0.75rem; color: var(--text-secondary); font-size: 0.85rem;">Direction</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${peersToDisplay.map((peer, idx) => {
                            const dirColor = peer.direction === 'inbound' ? '#4ade80' : '#60a5fa';
                            const dirIcon = peer.direction === 'inbound' ? '‚¨ÖÔ∏è' : '‚û°Ô∏è';
                            return `
                                <tr style="border-bottom: 1px solid rgba(162, 145, 255, 0.1);">
                                    <td style="padding: 0.75rem; color: var(--text-secondary);">${idx + 1}</td>
                                    <td style="padding: 0.75rem; color: var(--accent-blue); font-family: monospace;">${peer.vnode_tag || 'Unknown'}</td>
                                    <td style="padding: 0.75rem; color: var(--text); font-family: monospace; font-size: 0.85rem;">${peer.addr || 'N/A'}</td>
                                    <td style="padding: 0.75rem;">
                                        <span style="color: ${dirColor}; font-weight: 500;">
                                            ${dirIcon} ${peer.direction || 'unknown'}
                                        </span>
                                    </td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            `;

            displayedPeerCount = toShow;
            document.getElementById('peer-showing').textContent = displayedPeerCount;
            document.getElementById('peer-total').textContent = allPeers.length;
            
            if (displayedPeerCount < allPeers.length) {
                loadMoreBtn.style.display = 'block';
            } else {
                loadMoreBtn.style.display = 'none';
            }
        }

        function loadMorePeers() {
            renderPeerList();
            log(`üì• Loaded ${Math.min(PEERS_PER_PAGE, allPeers.length - displayedPeerCount + PEERS_PER_PAGE)} more peers`);
        }

        async function linkNodeWithWallet() {
            console.log('[DEBUG] linkNodeWithWallet() called');
            
            try {
                // Get wallet address from input
                const walletInput = document.getElementById('wallet-address-input');
                const walletAddress = walletInput.value.trim();
                
                if (!walletAddress) {
                    log('‚ùå Please enter your wallet address', 'error');
                    log('   1. Open http://127.0.0.1:7070/app#/wallet', 'info');
                    log('   2. Copy your wallet address (starts with 0x...)', 'info');
                    log('   3. Paste it above and click "Link Node"', 'info');
                    return;
                }
                
                if (!walletAddress.startsWith('0x') || walletAddress.length !== 42) {
                    log('‚ùå Invalid wallet address format (should be 0x... and 42 characters)', 'error');
                    return;
                }
                
                log('üîê Starting node linking process...', 'info');
                console.log('[DEBUG] Using wallet:', walletAddress);
                
                // Step 1: Register wallet (generates Ed25519 keys and binds to node)
                log('üîë Registering wallet and generating signing keys...', 'info');
                try {
                    const registerResponse = await fetch(`${API_BASE}/wallet/register`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ wallet_address: walletAddress })
                    });
                    
                    if (registerResponse.ok) {
                        const registerResult = await registerResponse.json();
                        console.log('[DEBUG] Registration result:', registerResult);
                        log('‚úÖ Wallet registered and bound to node', 'success');
                    } else {
                        const errorText = await registerResponse.text();
                        log(`‚ùå Registration failed: ${errorText}`, 'error');
                        return;
                    }
                } catch (regError) {
                    console.error('[DEBUG] Registration error:', regError);
                    log(`‚ùå Registration error: ${regError.message}`, 'error');
                    return;
                }
                
                // Step 1: Get challenge from backend
                log('üìù Requesting challenge from node...', 'info');
                const challengeResponse = await fetch(`${API_BASE}/node/approval/challenge`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ wallet_address: walletAddress })
                });
                
                if (!challengeResponse.ok) {
                    const errorText = await challengeResponse.text();
                    try {
                        const error = JSON.parse(errorText);
                        log(`‚ùå Failed to get challenge: ${error.error || 'Unknown error'}`, 'error');
                    } catch (e) {
                        log(`‚ùå Failed to get challenge: ${errorText}`, 'error');
                    }
                    return;
                }
                
                const challengeData = await challengeResponse.json();
                console.log('[DEBUG] Challenge received:', challengeData);
                log(`‚úÖ Challenge received (expires at ${challengeData.expires_at})`, 'success');
                
                // Step 2: Sign the challenge with wallet's Ed25519 key
                log('‚úçÔ∏è Signing challenge with wallet...', 'info');
                const signResponse = await fetch(`${API_BASE}/wallet/sign_message`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        wallet_address: walletAddress,
                        message: challengeData.message 
                    })
                });
                
                if (!signResponse.ok) {
                    const errorText = await signResponse.text();
                    try {
                        const error = JSON.parse(errorText);
                        log(`‚ùå Failed to sign message: ${error.error || 'Unknown error'}`, 'error');
                    } catch (e) {
                        log(`‚ùå Failed to sign message: ${errorText}`, 'error');
                    }
                    return;
                }
                
                const signData = await signResponse.json();
                console.log('[DEBUG] Signature received');
                log('‚úÖ Message signed successfully', 'success');
                
                // Step 3: Submit approval with signature
                log('üì§ Submitting approval to node...', 'info');
                const approvalResponse = await fetch(`${API_BASE}/node/approval/submit`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        wallet_address: walletAddress,
                        ts_unix: challengeData.ts_unix,
                        nonce_hex: challengeData.nonce_hex,
                        signature_b64: signData.signature_b64
                    })
                });
                
                const approvalText = await approvalResponse.text();
                let approvalResult;
                try {
                    approvalResult = JSON.parse(approvalText);
                } catch (e) {
                    approvalResult = { ok: false, error: approvalText };
                }
                console.log('[DEBUG] Approval result:', approvalResult);
                
                if (approvalResult.ok) {
                    log('‚úÖ Node approved successfully!', 'success');
                    log(`üîê Approved by wallet: ${signData.wallet_address}`, 'success');
                    log('‚õèÔ∏è Mining is now enabled', 'success');
                    
                    // Refresh status to show new approval state
                    await loadApprovalStatus();
                    await fetchStatus();
                } else {
                    log(`‚ùå Approval failed: ${approvalResult.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                console.error('[DEBUG] Approval error:', error);
                log(`‚ùå Approval error: ${error.message}`, 'error');
            }
        }

        // Shared node identity loaded once
        let nodeIdentityCache = null;
        let nodeIdentityLoading = false;

        async function loadNodeIdentity() {
            if (nodeIdentityCache || nodeIdentityLoading) return nodeIdentityCache;
            
            nodeIdentityLoading = true;
            try {
                const response = await fetch(`${API_BASE}/node/identity`);
                if (response.ok) {
                    const identity = await response.json();
                    nodeIdentityCache = identity;
                    
                    // Update Node Identity Panel
                    const nodeIdEl = document.getElementById('node-id');
                    const nodeFingerprintEl = document.getElementById('node-fingerprint');
                    const nodePubkeyEl = document.getElementById('node-pubkey');
                    const approvalStatusEl = document.getElementById('approval-status');
                    
                    if (nodeIdEl) nodeIdEl.textContent = identity.node_id || 'Unavailable';
                    if (nodeFingerprintEl) nodeFingerprintEl.textContent = identity.pubkey_fpr || 'Unavailable';
                    if (nodePubkeyEl) nodePubkeyEl.textContent = identity.public_key || 'Unavailable';
                    if (approvalStatusEl) {
                        if (identity.approved && identity.verified) {
                            approvalStatusEl.textContent = '‚úÖ Approved';
                            approvalStatusEl.style.color = 'var(--accent-green)';
                        } else {
                            approvalStatusEl.textContent = '‚è≥ Not Approved';
                            approvalStatusEl.style.color = '#fbbf24';
                        }
                    }
                    
                    // Update Link Wallet Panel
                    const nodeIdDisplayLink = document.getElementById('node-id-display-link');
                    if (nodeIdDisplayLink) {
                        nodeIdDisplayLink.textContent = identity.node_id || 'Unavailable';
                    }
                    
                    console.log('[NodeIdentity] Loaded:', identity);
                    return identity;
                }
            } catch (error) {
                console.error('[NodeIdentity] Failed to load:', error);
            } finally {
                nodeIdentityLoading = false;
            }
            return null;
        }

        let lastApprovalStatus = null; // Track last status to avoid duplicate logs
        
        async function loadApprovalStatus() {
            try {
                // Load approval status from backend
                const response = await fetch(`${API_BASE}/node/approval/status`);
                if (response.ok) {
                    const result = await response.json();
                    
                    const nodeIdEl = document.getElementById('node-id-display');
                    const approvalStateEl = document.getElementById('approval-state');
                    const currentWalletEl = document.getElementById('current-wallet');
                    const pendingRewardsEl = document.getElementById('pending-rewards-display');
                    
                    // Check if status changed
                    const statusChanged = JSON.stringify(lastApprovalStatus) !== JSON.stringify(result);
                    if (statusChanged) {
                        console.log('[DEBUG] Approval status changed:', result);
                        lastApprovalStatus = result;
                    }
                    
                    // Display node ID
                    if (result.node_id && nodeIdEl) {
                        nodeIdEl.textContent = result.node_id;
                    }
                    
                    // Display pending rewards
                    if (pendingRewardsEl && typeof result.pending_rewards !== 'undefined') {
                        const pendingLand = (result.pending_rewards / 1e18).toFixed(4);
                        pendingRewardsEl.textContent = pendingLand > 0 ? `${pendingLand} LAND` : '0 LAND';
                        if (parseFloat(pendingLand) > 0) {
                            pendingRewardsEl.style.color = '#fbbf24'; // Yellow/gold for pending
                        } else {
                            pendingRewardsEl.style.color = 'var(--text-secondary)';
                        }
                    }
                    
                    if (result.approved) {
                        if (approvalStateEl) {
                            approvalStateEl.textContent = '‚úÖ Linked & Approved';
                            approvalStateEl.style.color = 'var(--accent-green)';
                        }
                        
                        if (result.wallet_address && currentWalletEl) {
                            currentWalletEl.textContent = result.wallet_address;
                            // Only log on status change
                            if (statusChanged) {
                                log(`‚úÖ Node linked to wallet: ${result.wallet_address}`, 'success');
                            }
                        }
                    } else {
                        if (approvalStateEl) {
                            approvalStateEl.textContent = '‚ö†Ô∏è Not Linked';
                            approvalStateEl.style.color = '#fbbf24';
                        }
                        if (currentWalletEl) {
                            currentWalletEl.textContent = 'None';
                        }
                    }
                } else {
                    console.warn('[DEBUG] Approval status endpoint returned:', response.status);
                }
            } catch (error) {
                console.log('Could not load approval status:', error);
            }
        }

        function log(message, type = 'info') {
            const logEl = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'success' ? 'log-entry-success' : type === 'error' ? 'log-entry-error' : 'log-entry';
            
            // Store in allLogs array
            allLogs.unshift({ time: timestamp, message, type });
            if (allLogs.length > 200) allLogs.pop();
            
            // Apply filters
            if (logFilter === 'all' || logFilter === type) {
                if (!logSearchTerm || message.toLowerCase().includes(logSearchTerm.toLowerCase())) {
                    const entry = document.createElement('div');
                    entry.className = className;
                    entry.textContent = `[${timestamp}] ${message}`;
                    logEl.insertBefore(entry, logEl.firstChild);
                }
            }
            
            // Keep only last 50 visible entries
            while (logEl.children.length > 50) {
                logEl.removeChild(logEl.lastChild);
            }
            
            // Auto-scroll unless frozen
            if (!freezeScroll) {
                logEl.scrollTop = 0;
            }
        }

        // WebSocket Support
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            try {
                ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    const wsIndicator = document.getElementById('ws-indicator');
                    const wsDot = document.getElementById('ws-dot');
                    if (wsIndicator) wsIndicator.style.display = 'inline-flex';
                    if (wsDot) wsDot.className = 'ws-dot';
                    log('üîå WebSocket connected', 'success');
                };
                
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.type === 'block_mined') {
                        playBlockSound();
                        log(`üéâ Block #${data.height} mined!`, 'success');
                        refreshData();
                    }
                };
                
                ws.onerror = () => {
                    const wsDot = document.getElementById('ws-dot');
                    if (wsDot) wsDot.className = 'ws-dot disconnected';
                };
                
                ws.onclose = () => {
                    const wsIndicator = document.getElementById('ws-indicator');
                    if (wsIndicator) wsIndicator.style.display = 'none';
                    log('WebSocket unavailable, using polling');
                };
            } catch (e) {
                console.log('WebSocket not supported, using polling');
            }
        }

        function playBlockSound() {
            if (soundEnabled) {
                blockMinedSound.play().catch(() => {});
            }
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            localStorage.setItem('soundEnabled', soundEnabled);
            document.getElementById('sound-btn').querySelector('span:last-child').textContent = soundEnabled ? 'Sound: ON' : 'Sound: OFF';
            log(soundEnabled ? 'üîä Sound enabled' : 'üîá Sound disabled');
        }

        function setLogFilter(filter) {
            logFilter = filter;
            document.querySelectorAll('.filter-chip').forEach(chip => {
                chip.classList.toggle('active', chip.dataset.filter === filter);
            });
            filterLogs();
        }

        function filterLogs() {
            const logEl = document.getElementById('log');
            logEl.innerHTML = '';
            allLogs.filter(entry => {
                const matchesFilter = logFilter === 'all' || entry.type === logFilter;
                const matchesSearch = !logSearchTerm || entry.message.toLowerCase().includes(logSearchTerm.toLowerCase());
                return matchesFilter && matchesSearch;
            }).slice(0, 50).forEach(entry => {
                const div = document.createElement('div');
                div.className = `log-entry log-entry-${entry.type}`;
                div.textContent = `[${entry.time}] ${entry.message}`;
                logEl.appendChild(div);
            });
        }

        function toggleFreezeScroll() {
            freezeScroll = !freezeScroll;
            document.getElementById('freeze-scroll-btn').textContent = freezeScroll ? '‚ñ∂Ô∏è Resume' : '‚ùÑÔ∏è Freeze';
        }

        async function fetchRigHealth() {
            try {
                const response = await fetch(`${API_BASE}/metrics/health`);
                
                if (!response.ok) {
                    // Hide rig health section if endpoint doesn't exist
                    const rigEl = document.getElementById('rig-health');
                    if (rigEl) rigEl.style.display = 'none';
                    return;
                }
                
                const data = await response.json();
                const rigEl = document.getElementById('rig-health');
                if (rigEl) rigEl.style.display = 'block';
                
                // Try to parse health data if format matches
                if (data.cpu) {
                    const cpuUsage = document.getElementById('cpu-usage');
                    const cpuTemp = document.getElementById('cpu-temp');
                    if (cpuUsage) cpuUsage.textContent = `${data.cpu.pct}%`;
                    if (cpuTemp) {
                        cpuTemp.textContent = `${data.cpu.temp}¬∞C`;
                        cpuTemp.className = `temp-badge temp-${data.cpu.temp < 60 ? 'normal' : data.cpu.temp < 80 ? 'warm' : 'hot'}`;
                    }
                }
                
                if (data.gpu) {
                    const gpuCard = document.getElementById('gpu-card');
                    if (gpuCard) {
                        gpuCard.style.display = 'block';
                        const gpuUsage = document.getElementById('gpu-usage');
                        const gpuTemp = document.getElementById('gpu-temp');
                        if (gpuUsage) gpuUsage.textContent = `${data.gpu.pct}%`;
                        if (gpuTemp) gpuTemp.textContent = `${data.gpu.temp}¬∞C`;
                    }
                }
            } catch (error) {
                // Silent fail - rig health endpoint not available
                const rigEl = document.getElementById('rig-health');
                if (rigEl) rigEl.style.display = 'none';
            }
        }

        // Phase 10: Fetch P2P reachability status
        async function fetchReachabilityStatus() {
            try {
                const response = await fetch(`${API_BASE}/p2p/reachability/status`);
                if (!response.ok) return;
                
                const data = await response.json();
                
                const reachableEl = document.getElementById('p2p-reachable');
                const advertisedEl = document.getElementById('p2p-advertised');
                
                if (data.advertised_address) {
                    if (reachableEl) {
                        reachableEl.textContent = '‚úÖ Reachable';
                        reachableEl.style.color = '#10b981';
                    }
                    if (advertisedEl) {
                        advertisedEl.textContent = `üì° ${data.advertised_address}`;
                    }
                } else {
                    if (reachableEl) {
                        reachableEl.textContent = '‚ö†Ô∏è Not detected';
                        reachableEl.style.color = '#f59e0b';
                    }
                    if (advertisedEl) {
                        advertisedEl.textContent = 'External IP detection failed';
                    }
                }
            } catch (error) {
                // Silent fail - endpoint not available
            }
        }

        function openMetricsOverlay() {
            document.getElementById('metrics-overlay').classList.add('active');
            fetchDetailedMetrics();
        }

        function closeMetricsOverlay() {
            document.getElementById('metrics-overlay').classList.remove('active');
        }

        async function fetchDetailedMetrics() {
            const supply = await (await fetch(`${API_BASE}/supply`)).text();
            document.getElementById('metrics-supply').textContent = formatLAND(supply);
            metricsData = { 
                supply_raw: supply,
                supply_land: formatLAND(supply, false),
                vault: 0, 
                treasury: 0, 
                burned: 0 
            };
        }

        function copyMetricsJSON() {
            navigator.clipboard.writeText(JSON.stringify(metricsData, null, 2)).then(() => {
                log('üìã JSON copied', 'success');
            });
        }

        async function fetchStatus() {
            try {
                const response = await fetch(`${API_BASE}/status`);
                const data = await response.json();
                
                // The /status endpoint returns: height, best_peer_height, lag, mempool, peers (array), mining_allowed, gating, max_lag
                const statusDot = document.querySelector('.vision-status-dot');
                if (statusDot) {
                    statusDot.className = 'vision-status-dot status-dot'; // Connected
                }
                
                isConnected = true;
                document.getElementById('status-text').textContent = 'Connected';
                document.getElementById('height').textContent = data.height.toLocaleString();
                const peerCount = data.peers ? data.peers.length : 0;
                document.getElementById('peers').textContent = peerCount;
                document.getElementById('mempool').textContent = data.mempool || 0;
                
                // Update P2P connection readiness indicator (P2P Robustness #7)
                updateConnectionReadiness(peerCount);
                
                // Update constellation sync status
                updateConstellationStatus(data);
                
                // Update constellation link (v2.7.0)
                if (data.constellation_url) {
                    updateConstellationLink(data);
                }
                
                // Update node identity display (both locations)
                if (data.node_id) {
                    const nodeIdTop = document.getElementById('node-id-display');
                    const nodeIdLink = document.getElementById('node-id-display-link');
                    if (nodeIdTop) nodeIdTop.textContent = data.node_id;
                    if (nodeIdLink) nodeIdLink.textContent = data.node_id;
                }
                if (data.wallet_address) {
                    const shortWallet = data.wallet_address.substring(0, 12) + '...' + data.wallet_address.substring(data.wallet_address.length - 8);
                    document.getElementById('wallet-address-display').textContent = `Wallet: ${shortWallet}`;
                } else {
                    document.getElementById('wallet-address-display').textContent = 'Wallet: Not configured';
                }
                
                // Update mining blocked reason (if present)
                const blockReasonEl = document.getElementById('mining-block-reason');
                if (data.mining_blocked_reason) {
                    blockReasonEl.textContent = '‚ö†Ô∏è Mining blocked: ' + data.mining_blocked_reason;
                    blockReasonEl.style.display = 'block';
                } else if (data.mining_eligible) {
                    blockReasonEl.textContent = '‚úÖ Mining eligible';
                    blockReasonEl.style.color = 'var(--accent-green)';
                    blockReasonEl.style.display = 'block';
                } else {
                    blockReasonEl.style.display = 'none';
                }
                
                // Update approval status in the approval section
                const approvalStateEl = document.getElementById('approval-state');
                const currentWalletEl = document.getElementById('current-wallet');
                const pendingRewardsEl2 = document.getElementById('pending-rewards-display');
                if (data.approved) {
                    approvalStateEl.textContent = '‚úÖ Approved';
                    approvalStateEl.style.color = 'var(--accent-green)';
                    if (data.approved_wallet) {
                        currentWalletEl.textContent = data.approved_wallet;
                    }
                } else {
                    approvalStateEl.textContent = '‚ö†Ô∏è Not Approved';
                    approvalStateEl.style.color = '#fbbf24';
                }
                
                // Update pending rewards display
                if (pendingRewardsEl2 && typeof data.pending_rewards !== 'undefined') {
                    const pendingLand = (data.pending_rewards / 1e18).toFixed(4);
                    pendingRewardsEl2.textContent = pendingLand > 0 ? `${pendingLand} LAND` : '0 LAND';
                    if (parseFloat(pendingLand) > 0) {
                        pendingRewardsEl2.style.color = '#fbbf24';
                    } else {
                        pendingRewardsEl2.style.color = 'var(--text-secondary)';
                    }
                }
                
                // Update charts
                updateHashrateChart(data.height);
                updatePeerChart(peerCount);
                
                if (!firstStatusFetched) {
                    log('Connected to Vision Node', 'success');
                    firstStatusFetched = true;
                }
            } catch (error) {
                const statusDot = document.querySelector('.vision-status-dot');
                if (statusDot) {
                    statusDot.className = 'vision-status-dot status-dot offline';
                }
                
                isConnected = false;
                document.getElementById('status-text').textContent = 'Disconnected';
                log(`Connection error: ${error.message}`, 'error');
            }
        }

        // Update Constellation Sync Status Card
        function updateConstellationStatus(data) {
            // Extract sync status fields from API response
            const syncStatus = data.sync_status || 'syncing';
            const canMine = data.can_mine || false;
            const syncHeight = data.sync_height || data.height || 0;
            const networkHeight = data.network_estimated_height || data.best_peer_height || 0;
            const connectedPeers = data.connected_peers || (data.peers ? data.peers.length : 0);
            
            // Update metrics
            document.getElementById('metric-sync-height').textContent = syncHeight.toLocaleString();
            document.getElementById('metric-network-height').textContent = networkHeight.toLocaleString();
            document.getElementById('metric-peers').textContent = connectedPeers;
            
            // Update subtitle based on sync status
            const subtitle = document.getElementById('constellation-subtitle');
            const card = document.getElementById('constellation-status');
            
            switch (syncStatus) {
                case 'syncing':
                    subtitle.textContent = 'Linking with nearby stars‚Ä¶';
                    card.classList.remove('ready');
                    break;
                case 'behind':
                    subtitle.textContent = 'Catching up to the constellation‚Ä¶';
                    card.classList.remove('ready');
                    break;
                case 'incompatible':
                    subtitle.textContent = 'This star sees a different universe. Check your version or config.';
                    card.classList.remove('ready');
                    break;
                case 'ready':
                    subtitle.textContent = "You're synced. Ready to shine.";
                    card.classList.add('ready');
                    break;
                default:
                    subtitle.textContent = 'Syncing with fellow stars across the network‚Ä¶';
                    card.classList.remove('ready');
            }
            
            // Update hint text
            const hint = document.getElementById('mine-hint');
            if (canMine) {
                hint.textContent = '‚ú® Your node is synchronized and ready to mine! Use the mining controls below.';
                hint.style.borderColor = 'rgba(60, 246, 213, 0.4)';
                hint.style.background = 'rgba(60, 246, 213, 0.1)';
            } else {
                hint.textContent = 'Mining unlocks after your node is fully synced and sees at least 2 peers on the same chain.';
                hint.style.borderColor = 'rgba(162, 145, 255, 0.15)';
                hint.style.background = 'rgba(0, 0, 0, 0.3)';
            }
            
            // Update HTTP Backbone (7070) Status
            updateHttpBackboneStatus(data);
            
            // Update Node Identity
            updateNodeIdentity(data);
        }
        
        // Update Node Identity Display
        function updateNodeIdentity(data) {
            const nodeIdElem = document.getElementById('node-id');
            const pubkeyElem = document.getElementById('node-pubkey');
            const fingerprintElem = document.getElementById('node-fingerprint');
            const statusElem = document.getElementById('identity-status');
            const approvalStatusElem = document.getElementById('approval-status');
            const approvalSection = document.getElementById('approval-section');
            
            if (data.node_id) {
                nodeIdElem.textContent = data.node_id;
                nodeIdElem.title = 'Ed25519-derived node identifier (40 hex chars)';
            }
            
            if (data.node_pubkey) {
                pubkeyElem.textContent = data.node_pubkey;
                pubkeyElem.title = 'Ed25519 public key (base64)';
            }
            
            if (data.node_pubkey_fingerprint) {
                fingerprintElem.textContent = data.node_pubkey_fingerprint;
                fingerprintElem.title = 'SHA256(pubkey) first 8 bytes';
            }
            
            // Update approval status
            if (data.approved) {
                approvalStatusElem.textContent = '‚úÖ Approved';
                approvalStatusElem.style.color = 'var(--success)';
                if (data.approved_wallet) {
                    approvalStatusElem.title = `Approved by wallet: ${data.approved_wallet}`;
                }
                approvalSection.style.display = 'none';
            } else {
                approvalStatusElem.textContent = '‚ö† Not approved';
                approvalStatusElem.style.color = 'var(--warning)';
                approvalStatusElem.title = 'Node not yet approved by wallet signature';
                approvalSection.style.display = 'block';
            }
            
            // Always show verified since we have identity
            if (data.node_id && data.node_pubkey) {
                statusElem.textContent = '‚úÖ Identity: Verified (Ed25519-derived)';
                statusElem.style.color = 'var(--success)';
            } else {
                statusElem.textContent = '‚è≥ Loading identity...';
                statusElem.style.color = 'var(--text-secondary)';
            }
        }
        
        // Update HTTP Backbone Status (7070 Anchor Connectivity)
        function updateHttpBackboneStatus(data) {
            const httpBackbone = data.http_backbone || {};
            const exchangeOk = data.exchange_ok || false;
            
            // Update status indicator
            const statusElem = document.getElementById('backbone-status');
            if (httpBackbone.connected) {
                statusElem.textContent = '‚úÖ Connected';
                statusElem.style.color = 'var(--success)';
            } else {
                statusElem.textContent = '‚ö†Ô∏è No response';
                statusElem.style.color = 'var(--warning)';
            }
            
            // Update anchor URL (show last part of IP)
            const anchorElem = document.getElementById('backbone-anchor');
            if (httpBackbone.anchor) {
                // Extract IP from http://IP:7070 format
                const match = httpBackbone.anchor.match(/http:\/\/([^:]+):/);
                if (match && match[1]) {
                    anchorElem.textContent = match[1];
                } else {
                    anchorElem.textContent = httpBackbone.anchor;
                }
            } else {
                anchorElem.textContent = '‚Äî';
            }
            
            // Update latency
            const latencyElem = document.getElementById('backbone-latency');
            if (httpBackbone.latency_ms !== null && httpBackbone.latency_ms !== undefined) {
                latencyElem.textContent = `${httpBackbone.latency_ms}ms`;
                latencyElem.style.color = httpBackbone.latency_ms < 200 ? 'var(--success)' : 'var(--warning)';
            } else {
                latencyElem.textContent = '‚Äî';
            }
            
            // Update tip height
            const tipElem = document.getElementById('backbone-tip');
            if (httpBackbone.tip_height !== null && httpBackbone.tip_height !== undefined) {
                tipElem.textContent = httpBackbone.tip_height.toLocaleString();
            } else {
                tipElem.textContent = '‚Äî';
            }
            
            // Update exchange status
            const exchangeElem = document.getElementById('exchange-status');
            if (exchangeOk) {
                exchangeElem.textContent = 'üè¶ Exchange: ‚úÖ Ready';
                exchangeElem.style.color = 'var(--success)';
            } else {
                exchangeElem.textContent = 'üè¶ Exchange: ‚è∏ Disabled/Not Ready';
                exchangeElem.style.color = 'var(--text-secondary)';
            }
            
            // Update subtitle
            const subtitleElem = document.getElementById('backbone-subtitle');
            if (httpBackbone.connected) {
                subtitleElem.textContent = `Synced with anchor (${httpBackbone.latency_ms || '?'}ms)`;
            } else if (httpBackbone.last_error) {
                // Show shortened error
                const shortError = httpBackbone.last_error.substring(0, 40);
                subtitleElem.textContent = `Error: ${shortError}...`;
            } else {
                subtitleElem.textContent = 'Retrying connection...';
            }
        }
        
        // Update Website Integration Status
        async function updateWebsiteStatus() {
            try {
                const response = await fetch('/api/website/status');
                const data = await response.json();
                
                // Update status indicator
                const statusElem = document.getElementById('website-status');
                if (!statusElem) return; // Element doesn't exist, skip update
                
                if (data.reachable) {
                    statusElem.textContent = '‚úÖ Connected';
                    statusElem.style.color = 'var(--success)';
                } else if (data.last_error) {
                    statusElem.textContent = '‚ö†Ô∏è Error';
                    statusElem.style.color = 'var(--warning)';
                } else {
                    statusElem.textContent = '‚è≥ Connecting...';
                    statusElem.style.color = 'var(--text-secondary)';
                }
                
                // Update last heartbeat time
                const heartbeatElem = document.getElementById('website-last-heartbeat');
                if (!heartbeatElem) return;
                if (data.last_heartbeat_unix) {
                    const ago = Math.floor(Date.now() / 1000) - data.last_heartbeat_unix;
                    if (ago < 60) {
                        heartbeatElem.textContent = `${ago}s ago`;
                    } else if (ago < 3600) {
                        heartbeatElem.textContent = `${Math.floor(ago / 60)}m ago`;
                    } else {
                        heartbeatElem.textContent = `${Math.floor(ago / 3600)}h ago`;
                    }
                    heartbeatElem.style.color = ago < 90 ? 'var(--success)' : 'var(--warning)';
                } else {
                    heartbeatElem.textContent = '‚Äî';
                    heartbeatElem.style.color = 'var(--text-secondary)';
                }
                
                // Update HTTP status code
                const httpStatusElem = document.getElementById('website-http-status');
                if (!httpStatusElem) return;
                
                if (data.last_response_status) {
                    httpStatusElem.textContent = data.last_response_status;
                    httpStatusElem.style.color = data.last_response_status < 300 ? 'var(--success)' : 'var(--warning)';
                } else {
                    httpStatusElem.textContent = '‚Äî';
                    httpStatusElem.style.color = 'var(--text-secondary)';
                }
                
                // Update success rate
                const successRateElem = document.getElementById('website-success-rate');
                if (!successRateElem) return;
                
                const successRate = data.total_sent > 0 ? 
                    ((data.total_success / data.total_sent) * 100).toFixed(1) : 0;
                successRateElem.textContent = `${successRate}%`;
                successRateElem.style.color = successRate > 90 ? 'var(--success)' : 
                                               successRate > 70 ? 'var(--warning)' : 'var(--error)';
                
                // Update hint with error if present
                const hintElem = document.getElementById('website-hint');
                if (!hintElem) return;
                
                if (data.last_error && !data.reachable) {
                    const shortError = data.last_error.length > 50 ? 
                        data.last_error.substring(0, 50) + '...' : data.last_error;
                    hintElem.textContent = `‚ö†Ô∏è ${shortError}`;
                } else {
                    hintElem.textContent = 'üì° Sends node status every 30 seconds (non-blocking)';
                }
            } catch (error) {
                console.error('Failed to fetch website status:', error);
                // Don't log to panel - this is background status
            }
        }
        
        // Fetch website status every 10 seconds
        setInterval(updateWebsiteStatus, 10000);
        setTimeout(updateWebsiteStatus, 2000); // Initial fetch after 2 seconds

        // Update Ready Status from /api/ready
        async function updateReadyStatus() {
            try {
                const resp = await fetch('/api/ready', { cache: 'no-store' });
                const data = await resp.json();
                
                // Update icon
                const icon = document.getElementById('ready-icon');
                const subtitle = document.getElementById('ready-subtitle');
                const message = document.getElementById('ready-message');
                
                if (data.ready) {
                    icon.textContent = '‚úÖ';
                    subtitle.textContent = 'Ready to participate';
                    message.textContent = 'Node is fully operational and can earn rewards.';
                    message.style.borderColor = 'rgba(16, 185, 129, 0.3)';
                    message.style.background = 'rgba(16, 185, 129, 0.05)';
                } else {
                    icon.textContent = '‚è≥';
                    subtitle.textContent = 'Not ready yet';
                    const reasons = data.reasons && data.reasons.length > 0 ? data.reasons.join(', ') : 'Syncing...';
                    message.textContent = `Waiting: ${reasons}`;
                    message.style.borderColor = 'rgba(245, 158, 11, 0.3)';
                    message.style.background = 'rgba(245, 158, 11, 0.05)';
                }
                
                // Update metrics
                document.getElementById('ready-backbone').textContent = data.backbone_connected ? '‚úÖ' : '‚ùå';
                document.getElementById('ready-sync').textContent = data.chain_synced ? '‚úÖ' : `‚ùå ${data.chain_lag} behind`;
                document.getElementById('ready-website').textContent = data.website_reachable ? '‚úÖ' : '‚ö†Ô∏è';
                document.getElementById('ready-approval').textContent = data.node_approved ? '‚úÖ' : '‚ö†Ô∏è';
                
            } catch (err) {
                console.debug('Failed to fetch ready status:', err);
            }
        }

        // Update Constellation Link in Website Status
        function updateConstellationLink(statusData) {
            const linkEl = document.getElementById('constellation-link-status');
            
            if (statusData.website_reachable && statusData.website_registered) {
                // Registered - show clickable link
                linkEl.innerHTML = `üîó <a href="${statusData.constellation_url}" target="_blank" style="color: #10b981; text-decoration: underline;">View in Constellation ‚Üí</a>`;
            } else if (statusData.website_reachable) {
                // Reachable but not registered yet
                linkEl.innerHTML = `üîó <a href="${statusData.constellation_url}" target="_blank" style="color: #f59e0b;">Pending Registration...</a>`;
            } else {
                // Not reachable
                linkEl.textContent = 'üîó Constellation: Retrying connection...';
            }
        }

        // Call ready status in main update loop
        setInterval(updateReadyStatus, 10000); // Every 10 seconds
        setTimeout(updateReadyStatus, 2000); // Initial fetch after 2s

        async function fetchSupply() {
            try {
                const response = await fetch(`${API_BASE}/supply`);
                const supply = await response.text();
                document.getElementById('supply').textContent = formatLAND(supply);
            } catch (error) {
                log(`Supply fetch error: ${error.message}`, 'error');
            }
        }

        async function fetchMempoolSize() {
            try {
                const response = await fetch(`${API_BASE}/mempool_size`);
                const size = await response.text();
                document.getElementById('mempool').textContent = size;
            } catch (error) {
                log(`Mempool fetch error: ${error.message}`, 'error');
            }
        }

        let miningInProgress = false;
        // Legacy manual mining variables - no longer needed with PoW mining
        // let autoMineInterval = null;
        // let miningStats = { totalMined: 0, successRate: 100, avgTime: 0 };

        // Legacy manual mining function - no longer needed with PoW mining
        // async function mineBlock() { ... }

        // Legacy manual mining functions - no longer needed with PoW mining
        // async function startAutoMine() { ... }
        // function stopAutoMine() { ... }
        // function toggleAutoMine() { ... }
        // function updateMiningStats() { ... }

        // Update connection readiness indicator (P2P Robustness #7)
        async function updateConnectionReadiness(peerCount) {
            const container = document.getElementById('connection-readiness');
            const icon = document.getElementById('connection-readiness-icon');
            const text = document.getElementById('connection-readiness-text');
            const detail = document.getElementById('connection-readiness-detail');
            
            // Fetch p2p_health status from constellation API
            const status = await fetchConstellationStatus();
            const p2pHealth = status?.p2p_health || 'isolated';
            
            // Map health status to UI states
            const healthConfig = {
                'isolated': {
                    bg: 'rgba(220, 38, 38, 0.1)',
                    border: 'rgba(220, 38, 38, 0.5)',
                    icon: '‚ùå',
                    text: 'ISOLATED',
                    color: '#dc2626',
                    detail: 'No peers connected - mining blocked'
                },
                'weak': {
                    bg: 'rgba(245, 158, 11, 0.1)',
                    border: 'rgba(245, 158, 11, 0.5)',
                    icon: '‚ö†Ô∏è',
                    text: 'WEAK',
                    color: '#f59e0b',
                    detail: `${peerCount} peer - mining enabled but vulnerable`
                },
                'ok': {
                    bg: 'rgba(34, 197, 94, 0.1)',
                    border: 'rgba(34, 197, 94, 0.5)',
                    icon: 'üü¢',
                    text: 'OK',
                    color: '#22c55e',
                    detail: `${peerCount} peers - stable mining connection`
                },
                'stable': {
                    bg: 'rgba(34, 197, 94, 0.1)',
                    border: 'rgba(34, 197, 94, 0.5)',
                    icon: 'üü¢',
                    text: 'STABLE',
                    color: '#22c55e',
                    detail: `${peerCount} peers - excellent network health`
                },
                'immortal': {
                    bg: 'rgba(59, 130, 246, 0.1)',
                    border: 'rgba(59, 130, 246, 0.5)',
                    icon: 'üîµ',
                    text: 'IMMORTAL',
                    color: '#3b82f6',
                    detail: `${peerCount} peers - maximum resilience achieved! üéâ`
                }
            };
            
            const config = healthConfig[p2pHealth] || healthConfig['isolated'];
            
            container.style.background = config.bg;
            container.style.borderColor = config.border;
            icon.textContent = config.icon;
            text.textContent = config.text;
            text.style.color = config.color;
            detail.textContent = config.detail;
        }

        async function refreshData() {
            await Promise.all([
                fetchStatus(), // Now includes mempool data
                fetchSupply(),
                fetchRecentBlocks(),
                fetchPeers()
            ]);
        }

        // Event listeners
        const refreshBtn = document.getElementById('refresh-btn');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => {
                log('Refreshing data...');
                refreshData();
            });
        }
        
        const clearLogBtn = document.getElementById('clear-log-btn');
        if (clearLogBtn) {
            clearLogBtn.addEventListener('click', () => {
                document.getElementById('log').innerHTML = '';
                log('Log cleared');
            });
        }
        
        const linkNodeBtn = document.getElementById('link-node-btn');
        if (linkNodeBtn) {
            linkNodeBtn.addEventListener('click', linkNodeWithWallet);
            console.log('‚úÖ Link Node button event listener attached');
        } else {
            console.error('‚ùå Link Node button not found in DOM');
        }

        // Make Fans Go Brr buttons (optional mining)
        const makeFansBtn = document.getElementById('make-fans-go-brr-btn');
        const stopFansBtn = document.getElementById('stop-fans-btn');
        const fanStatus = document.getElementById('fan-status');

        if (makeFansBtn) {
            makeFansBtn.addEventListener('click', async () => {
                makeFansBtn.disabled = true;
                makeFansBtn.innerHTML = '<span>‚è≥</span><span>Starting mining...</span>';
                
                try {
                    // Start mining with current config
                    const threads = minerConfig?.threads || navigator.hardwareConcurrency || 4;
                    const result = await setMinerThreads(threads);
                    
                    if (result) {
                        showToast('üî• Mining started! Fans going BRRRR!', 'success');
                        makeFansBtn.style.display = 'none';
                        stopFansBtn.style.display = 'block';
                        fanStatus.textContent = 'BRRRR! (mining active)';
                        fanStatus.style.color = 'var(--accent-green)';
                    } else {
                        throw new Error('Failed to start mining');
                    }
                } catch (e) {
                    showToast('Failed to start mining: ' + e.message, 'error');
                    makeFansBtn.innerHTML = '<span>üí®</span><span>Make Fans Go BRRRR!</span>';
                } finally {
                    makeFansBtn.disabled = false;
                }
            });
        }

        if (stopFansBtn) {
            stopFansBtn.addEventListener('click', async () => {
                stopFansBtn.disabled = true;
                stopFansBtn.innerHTML = '<span>‚è≥</span><span>Stopping...</span>';
                
                try {
                    const result = await setMinerThreads(0);
                    
                    if (result) {
                        showToast('Mining stopped. Fans quieting down...', 'info');
                        stopFansBtn.style.display = 'none';
                        makeFansBtn.style.display = 'block';
                        fanStatus.textContent = 'Quiet (no mining)';
                        fanStatus.style.color = 'var(--accent-cyan)';
                    } else {
                        throw new Error('Failed to stop mining');
                    }
                } catch (e) {
                    showToast('Failed to stop mining: ' + e.message, 'error');
                    stopFansBtn.innerHTML = '<span>üõë</span><span>Stop Mining</span>';
                } finally {
                    stopFansBtn.disabled = false;
                }
            });
        }

        // New feature event listeners
        document.getElementById('metrics-btn').addEventListener('click', openMetricsOverlay);
        document.getElementById('sound-btn').addEventListener('click', toggleSound);
        document.getElementById('freeze-scroll-btn').addEventListener('click', toggleFreezeScroll);
        document.getElementById('close-metrics').addEventListener('click', closeMetricsOverlay);
        document.getElementById('copy-json-btn').addEventListener('click', copyMetricsJSON);
        
        // Log filter chips
        document.querySelectorAll('.filter-chip').forEach(chip => {
            chip.addEventListener('click', () => setLogFilter(chip.dataset.filter));
        });
        
        // Log search
        document.getElementById('log-search').addEventListener('input', (e) => {
            logSearchTerm = e.target.value.toLowerCase();
            filterLogs();
        });

        // Auto-refresh every 5 seconds
        setInterval(refreshData, 5000);

        // Load node identity once on page load
        loadNodeIdentity();

        // Refresh rig health every 10 seconds
        setInterval(fetchRigHealth, 10000);

        // Phase 10: Refresh P2P reachability every 30 seconds
        setInterval(fetchReachabilityStatus, 30000);

        // Refresh approval status every 10 seconds
        setInterval(loadApprovalStatus, 10000);

        // Refresh miner intelligence every 10 seconds
        setInterval(async () => {
            const intelligence = await getMinerIntelligence();
            if (intelligence) {
                updateMinerIntelligence(intelligence);
            }
        }, 10000);

        // Initial load
        log('Vision Node Miner Panel initialized');
        initCharts();
        loadApprovalStatus();
        refreshData();
        
        // Initial intelligence fetch
        getMinerIntelligence().then(intelligence => {
            if (intelligence) {
                updateMinerIntelligence(intelligence);
            }
        });
        
        // Initialize advanced features
        connectWebSocket();
        fetchRigHealth();
        fetchReachabilityStatus();  // Phase 10: Initial reachability check
        
        // Initialize miner controls and polling
        initMinerControls();

        // ========================================
        // WEBSITE API INTEGRATION
        // ========================================
        async function fetchNetworkMood() {
            try {
                const response = await fetch(`${API_BASE}/mood`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                
                // Show mood data in log
                log(`üåê Network Mood: ${data.mood.toUpperCase()} (${(data.score * 100).toFixed(0)}%)`, 'info');
                log(`   ${data.reason}`, 'info');
                log(`   Chain: ${data.details.chain_health} | Mempool: ${data.details.mempool_pressure} | Activity: ${data.details.network_activity}`, 'info');
                
                // Update UI with mood
                const moodEmoji = {
                    'calm': 'üòå',
                    'guardian': 'üõ°Ô∏è',
                    'celebration': 'üéâ',
                    'warning': '‚ö†Ô∏è',
                    'wounded': 'ü©π',
                    'storm': '‚õàÔ∏è',
                    'rage': 'üò§'
                };
                
                document.getElementById('network-mood-btn').innerHTML = `
                    <span>${moodEmoji[data.mood] || 'üåê'}</span>
                    <span>${data.mood.charAt(0).toUpperCase() + data.mood.slice(1)}</span>
                `;
                
                return data;
            } catch (error) {
                log(`‚ùå Failed to fetch network mood: ${error.message}`, 'error');
                return null;
            }
        }

        async function fetchConstellationData() {
            try {
                const response = await fetch(`${API_BASE}/constellation`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                
                log(`‚≠ê Constellation Status:`, 'info');
                log(`   Sentinel: ${data.sentinel.id} @ ${data.sentinel.address} (height: ${data.sentinel.height})`, 'info');
                log(`   Nodes: ${data.nodes.length} connected`, 'info');
                
                if (data.nodes.length > 0) {
                    data.nodes.slice(0, 5).forEach(node => {
                        log(`   - ${node.id}: ${node.address} (height: ${node.height}, rep: ${node.reputation.toFixed(2)})`, 'info');
                    });
                    if (data.nodes.length > 5) {
                        log(`   ... and ${data.nodes.length - 5} more`, 'info');
                    }
                }
                
                return data;
            } catch (error) {
                log(`‚ùå Failed to fetch constellation: ${error.message}`, 'error');
                return null;
            }
        }

        async function fetchHealthPublic() {
            try {
                const response = await fetch(`${API_BASE}/health_api/public`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                
                log(`üè• Network Health:`, 'info');
                log(`   Mood: ${data.network_mood}`, 'info');
                log(`   Peers: ${data.peer_counts.total} (${data.peer_counts.healthy} healthy, ${data.peer_counts.unstable} unstable)`, 'info');
                if (data.active_incidents && data.active_incidents.length > 0) {
                    log(`   ‚ö†Ô∏è Active incidents: ${data.active_incidents.length}`, 'warning');
                }
                
                return data;
            } catch (error) {
                log(`‚ùå Failed to fetch health data: ${error.message}`, 'error');
                return null;
            }
        }

        // Add event listeners for new buttons
        document.getElementById('network-mood-btn').addEventListener('click', fetchNetworkMood);

        // Poll network mood every 10 seconds
        setInterval(fetchNetworkMood, 10000);
        
        // Initial fetch
        setTimeout(() => {
            fetchNetworkMood();
        }, 2000);

        // ========================================
        // POOL MINING FUNCTIONALITY
        // ========================================
        let currentMiningMode = localStorage.getItem('miningMode') || 'Solo';
        let poolStatsInterval = null;
        let selectedPoolPort = 7072;

        const modeDescriptions = {
            'Solo': 'Solo: Mine independently and receive full block rewards',
            'HostPool': 'Host Pool: Coordinate workers and distribute rewards proportionally',
            'JoinPool': 'Join Pool: Contribute hashpower to a remote pool for steady income',
            'Farm': 'Farm: Manage multiple remote mining rigs with profiles and schedules'
        };

        function initPoolUI() {
            // Set initial mode
            updateMiningMode(currentMiningMode);

            // Mode selector buttons
            document.querySelectorAll('.mining-mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const mode = btn.dataset.mode;
                    updateMiningMode(mode);
                    setMiningMode(mode);
                });
            });

            // Pool port selector
            document.querySelectorAll('.pool-port-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const port = parseInt(btn.dataset.port);
                    selectPoolPort(port);
                });
            });
            selectPoolPort(7072); // Default

            // Host pool controls
            document.getElementById('start-pool-btn').addEventListener('click', startPool);
            document.getElementById('stop-pool-btn').addEventListener('click', stopPool);
            document.getElementById('pool-fee-input').addEventListener('input', updatePoolFeeDisplay);

            // Join pool controls
            document.getElementById('join-pool-btn').addEventListener('click', joinPool);
            document.getElementById('disconnect-pool-btn').addEventListener('click', disconnectFromPool);

            // Load saved pool URL
            const savedPoolUrl = localStorage.getItem('poolUrl');
            if (savedPoolUrl) {
                document.getElementById('pool-url-input').value = savedPoolUrl;
            }
            
            // Load saved worker name
            const savedWorkerName = localStorage.getItem('workerName');
            if (savedWorkerName) {
                document.getElementById('worker-name-input').value = savedWorkerName;
            }

            // Load saved pool name (for hosting)
            const savedPoolName = localStorage.getItem('poolName');
            if (savedPoolName) {
                document.getElementById('pool-name-input').value = savedPoolName;
            }
        }

        function selectPoolPort(port) {
            selectedPoolPort = port;
            document.querySelectorAll('.pool-port-btn').forEach(btn => {
                if (parseInt(btn.dataset.port) === port) {
                    btn.classList.remove('btn-secondary');
                    btn.classList.add('btn-primary');
                } else {
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-secondary');
                }
            });
        }

        function updateMiningMode(mode) {
            currentMiningMode = mode;
            localStorage.setItem('miningMode', mode);

            // Update UI
            document.querySelectorAll('.mining-mode-btn').forEach(btn => {
                if (btn.dataset.mode === mode) {
                    btn.classList.remove('btn-secondary');
                    btn.classList.add('btn-primary');
                } else {
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-secondary');
                }
            });

            document.getElementById('mode-description').textContent = modeDescriptions[mode];

            // Show/hide pool configuration and farm section
            const poolConfigEl = document.getElementById('pool-config');
            const hostPoolSettings = document.getElementById('host-pool-settings');
            const joinPoolSettings = document.getElementById('join-pool-settings');
            const farmModeSection = document.getElementById('farm-mode-section');

            if (mode === 'Solo') {
                poolConfigEl.style.display = 'none';
                farmModeSection.style.display = 'none';
                stopPoolStatsPolling();
            } else if (mode === 'HostPool') {
                poolConfigEl.style.display = 'block';
                hostPoolSettings.style.display = 'block';
                joinPoolSettings.style.display = 'none';
                farmModeSection.style.display = 'none';
            } else if (mode === 'JoinPool') {
                poolConfigEl.style.display = 'block';
                hostPoolSettings.style.display = 'none';
                joinPoolSettings.style.display = 'block';
                farmModeSection.style.display = 'none';
            } else if (mode === 'Farm') {
                poolConfigEl.style.display = 'none';
                farmModeSection.style.display = 'block';
                stopPoolStatsPolling();
                farmRefresh();
            }

            log(`Mining mode set to: ${mode}`, 'success');
        }

        async function setMiningMode(mode) {
            try {
                const response = await fetch('/api/pool/mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode })
                });

                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const result = await response.json();
                if (result.ok) {
                    log(`‚úÖ Mining mode updated: ${mode}`, 'success');
                } else {
                    log(`‚ùå Failed to set mode: ${result.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                log(`‚ùå Error setting mining mode: ${error.message}`, 'error');
            }
        }

        function updatePoolFeeDisplay() {
            const feeInput = document.getElementById('pool-fee-input');
            document.getElementById('current-pool-fee').textContent = `${feeInput.value}%`;
        }

        async function startPool() {
            const feeInput = document.getElementById('pool-fee-input');
            const poolFee = parseFloat(feeInput.value) || 1.5;
            const poolNameInput = document.getElementById('pool-name-input');
            const poolName = poolNameInput.value.trim() || 'Unnamed Pool';

            // Save pool name
            localStorage.setItem('poolName', poolName);

            try {
                const response = await fetch('/api/pool/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        pool_fee: poolFee,
                        pool_name: poolName,
                        pool_port: selectedPoolPort
                    })
                });

                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const result = await response.json();
                if (result.ok) {
                    document.getElementById('start-pool-btn').style.display = 'none';
                    document.getElementById('stop-pool-btn').style.display = 'block';
                    document.getElementById('pool-status').textContent = 'Running';
                    document.getElementById('pool-status').style.color = 'var(--accent-green)';
                    
                    // Display generated pool URL and name
                    if (result.pool_url) {
                        document.getElementById('pool-url-generated').value = result.pool_url;
                        document.getElementById('pool-url-display').style.display = 'block';
                        
                        // Show pool name in the URL display
                        const poolNameDisplay = document.getElementById('pool-name-display');
                        if (poolNameDisplay && result.pool_name) {
                            poolNameDisplay.textContent = result.pool_name;
                            poolNameDisplay.style.display = 'inline';
                        }
                    }
                    
                    // Show pool stats and worker list
                    document.getElementById('pool-stats').style.display = 'block';
                    document.getElementById('worker-list').style.display = 'block';
                    
                    startPoolStatsPolling();
                    log(`‚úÖ Pool "${poolName}" started on port ${selectedPoolPort} with ${poolFee}% fee`, 'success');
                    log(`üåê Pool URL: ${result.pool_url}`, 'info');
                } else {
                    log(`‚ùå Failed to start pool: ${result.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                log(`‚ùå Error starting pool: ${error.message}`, 'error');
            }
        }

        async function stopPool() {
            try {
                const response = await fetch('/api/pool/stop', {
                    method: 'POST'
                });

                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const result = await response.json();
                if (result.ok) {
                    document.getElementById('start-pool-btn').style.display = 'block';
                    document.getElementById('stop-pool-btn').style.display = 'none';
                    document.getElementById('pool-status').textContent = 'Stopped';
                    document.getElementById('pool-status').style.color = 'var(--text-secondary)';
                    
                    // Hide pool stats, worker list, and URL display
                    document.getElementById('pool-stats').style.display = 'none';
                    document.getElementById('worker-list').style.display = 'none';
                    document.getElementById('pool-url-display').style.display = 'none';
                    
                    stopPoolStatsPolling();
                    log('‚èπÔ∏è Pool stopped', 'info');
                } else {
                    log(`‚ùå Failed to stop pool: ${result.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                log(`‚ùå Error stopping pool: ${error.message}`, 'error');
            }
        }

        async function joinPool() {
            const poolUrlInput = document.getElementById('pool-url-input');
            const poolUrl = poolUrlInput.value.trim();
            
            const workerNameInput = document.getElementById('worker-name-input');
            const workerName = workerNameInput.value.trim();

            if (!poolUrl) {
                log('‚ùå Please enter a pool URL', 'error');
                return;
            }

            // Save to localStorage
            localStorage.setItem('poolUrl', poolUrl);
            if (workerName) {
                localStorage.setItem('workerName', workerName);
            }

            try {
                // Step 1: Set mining mode to JoinPool
                log('üîÑ Setting mining mode to JoinPool...', 'info');
                const modeResponse = await fetch('/api/pool/mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: 'JoinPool' })
                });

                if (!modeResponse.ok) {
                    throw new Error(`Failed to set mode: HTTP ${modeResponse.status}`);
                }

                // Step 2: Configure pool URL (and worker name) in backend and save
                log('üîÑ Configuring pool connection...', 'info');
                const configResponse = await fetch('/api/pool/configure', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        host_address: poolUrl,
                        worker_name: workerName || null,
                        save_and_restart: true
                    })
                });

                if (!configResponse.ok) {
                    throw new Error(`Failed to configure: HTTP ${configResponse.status}`);
                }
                
                const configResult = await configResponse.json();
                if (configResult.status === 'node_exiting_for_restart') {
                    log('üîÑ Node restarting to apply pool configuration...', 'info');
                    log('‚è≥ Please wait 5 seconds for node to restart...', 'info');
                    
                    // Wait for restart
                    await new Promise(resolve => setTimeout(resolve, 5000));
                    
                    // Check if node is back up
                    let retries = 0;
                    while (retries < 10) {
                        try {
                            await fetch('/api/height');
                            log('‚úÖ Node restarted successfully', 'success');
                            break;
                        } catch (e) {
                            retries++;
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                    }
                }

                // Step 3: Test connection to pool
                log('üîÑ Testing pool connection...', 'info');
                const testResponse = await fetch(`${poolUrl}/api/pool/stats`, {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                });

                if (!testResponse.ok) {
                    throw new Error(`Pool unreachable: HTTP ${testResponse.status}`);
                }

                const poolStats = await testResponse.json();
                
                // Update UI
                document.getElementById('join-pool-status').textContent = 'Connected';
                document.getElementById('join-pool-status').style.color = 'var(--accent-green)';
                document.getElementById('join-pool-btn').style.display = 'none';
                document.getElementById('disconnect-pool-btn').style.display = 'block';
                
                // Show pool info
                const poolInfoDisplay = document.getElementById('pool-info-display');
                poolInfoDisplay.style.display = 'block';
                document.getElementById('connected-pool-name').textContent = poolStats.pool_name || 'Unknown Pool';
                document.getElementById('connected-pool-workers').textContent = poolStats.worker_count || 0;
                document.getElementById('connected-pool-hashrate').textContent = formatHashrate(poolStats.total_hashrate || 0);
                
                log(`‚úÖ Connected to pool: ${poolStats.pool_name || poolUrl}`, 'success');
                log(`üìä Pool hashrate: ${formatHashrate(poolStats.total_hashrate || 0)}`, 'info');
                log(`üë∑ Active workers: ${poolStats.worker_count || 0}`, 'info');
                log('üí° Click "Start Mining" to begin contributing hashpower', 'info');
                
            } catch (error) {
                log(`‚ùå Error joining pool: ${error.message}`, 'error');
                document.getElementById('join-pool-status').textContent = 'Connection failed';
                document.getElementById('join-pool-status').style.color = '#ef4444';
                
                // Revert mode to Solo on failure
                try {
                    await fetch('/api/pool/mode', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ mode: 'Solo' })
                    });
                } catch (e) {
                    console.error('Failed to revert mode:', e);
                }
            }
        }

        async function disconnectFromPool() {
            try {
                // Stop mining first
                await fetch('/api/miner/stop', { method: 'POST' });
                
                // Set mode back to Solo
                await fetch('/api/pool/mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: 'Solo' })
                });
                
                // Update UI
                document.getElementById('join-pool-status').textContent = 'Not connected';
                document.getElementById('join-pool-status').style.color = 'var(--text-secondary)';
                document.getElementById('join-pool-btn').style.display = 'block';
                document.getElementById('disconnect-pool-btn').style.display = 'none';
                document.getElementById('pool-info-display').style.display = 'none';
                
                // Update mining mode UI
                updateMiningMode('Solo');
                
                log('‚úÖ Disconnected from pool', 'success');
                log('üí° Switched back to Solo mining mode', 'info');
                
            } catch (error) {
                log(`‚ùå Error disconnecting: ${error.message}`, 'error');
            }
        }

        function startPoolStatsPolling() {
            if (poolStatsInterval) clearInterval(poolStatsInterval);
            
            poolStatsInterval = setInterval(async () => {
                try {
                    const response = await fetch('/api/pool/stats', { cache: 'no-store' });
                    if (!response.ok) return;
                    
                    const stats = await response.json();
                    updatePoolStats(stats);
                } catch (error) {
                    console.error('Pool stats fetch error:', error);
                }
            }, 5000);

            // Fetch immediately
            fetch('/api/pool/stats', { cache: 'no-store' })
                .then(r => r.json())
                .then(stats => updatePoolStats(stats))
                .catch(e => console.error('Initial pool stats fetch error:', e));
        }

        function stopPoolStatsPolling() {
            if (poolStatsInterval) {
                clearInterval(poolStatsInterval);
                poolStatsInterval = null;
            }
        }

        function updatePoolStats(stats) {
            // Update pool statistics
            document.getElementById('pool-workers').textContent = stats.worker_count || 0;
            document.getElementById('pool-hashrate').textContent = formatHashrate(stats.total_hashrate || 0);
            document.getElementById('pool-shares').textContent = stats.total_shares || 0;
            document.getElementById('pool-blocks').textContent = stats.blocks_found || 0;

            // Update pool name if available
            if (stats.pool_name) {
                document.getElementById('pool-stats-name').textContent = stats.pool_name;
            }

            // Update worker list
            if (stats.workers && Array.isArray(stats.workers)) {
                updateWorkerList(stats.workers, stats.total_shares || 0);
            }
        }

        function updateWorkerList(workers, totalShares) {
            const tbody = document.getElementById('worker-table-body');
            
            if (workers.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="5" style="text-align: center; padding: 2rem; color: var(--text-secondary);">
                            No workers connected
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = workers.map(worker => {
                const sharePercent = totalShares > 0 ? ((worker.total_shares / totalShares) * 100).toFixed(2) : 0;
                
                // Display worker name if available, otherwise use truncated ID
                const workerDisplay = worker.worker_name 
                    ? `<strong style="color: var(--accent-blue);">${worker.worker_name}</strong><br><span style="font-size: 0.75rem; color: var(--text-secondary);">${worker.worker_id.substring(0, 12)}...</span>`
                    : `<span style="font-family: 'Courier New', monospace;">${worker.worker_id.substring(0, 12)}...</span>`;
                
                return `
                    <tr style="border-bottom: 1px solid var(--border-color);">
                        <td style="padding: 0.75rem; color: var(--accent-blue);">
                            ${workerDisplay}
                        </td>
                        <td style="padding: 0.75rem; font-family: 'Courier New', monospace; color: var(--text-secondary); font-size: 0.85rem;">
                            ${worker.wallet_address.substring(0, 20)}...
                        </td>
                        <td style="padding: 0.75rem; text-align: right; color: var(--accent-green);">
                            ${worker.total_shares.toLocaleString()}
                        </td>
                        <td style="padding: 0.75rem; text-align: right;">
                            ${formatHashrate(worker.reported_hashrate || 0)}
                        </td>
                        <td style="padding: 0.75rem; text-align: right; color: var(--accent-purple);">
                            ${worker.estimated_payout || 'N/A'}
                        </td>
                    </tr>
                `;
            }).join('');
        }

        // Initialize pool UI on page load
        setTimeout(initPoolUI, 500);
        
        // ========================================
        // END POOL MINING FUNCTIONALITY
        // ========================================
        
        // Create subtle shooting stars effect
        function createShootingStars(container) {
            const createStar = () => {
                const star = document.createElement('div');
                star.className = 'shooting-star';
                star.style.top = Math.random() * 40 + '%';
                star.style.right = Math.random() * 30 + '%';
                star.style.animationDelay = (Math.random() * 8) + 's';
                star.style.animationDuration = (3 + Math.random() * 2) + 's';
                container.appendChild(star);
                
                // Remove and recreate after animation
                setTimeout(() => {
                    star.remove();
                    setTimeout(() => createStar(), Math.random() * 5000); // Random delay between stars
                }, (3 + Math.random() * 2) * 1000);
            };
            
            // Create only 2 subtle shooting stars
            for (let i = 0; i < 2; i++) {
                setTimeout(() => createStar(), i * 4000);
            }
        }
        
        // Initialize 3D spinning globe with enhanced space background
        setTimeout(() => {
            try {
                if (typeof Globe !== 'undefined' && typeof THREE !== 'undefined') {
                    const globeElement = document.getElementById('peer-map');
                    
                    // Create subtle shooting stars
                    createShootingStars(globeElement);
                    
                    geoMap = Globe()
                        (globeElement)
                        .globeImageUrl('/assets/vision-earth-night.jpg')
                        .bumpImageUrl('/assets/earthlights1k.jpg')
                        .backgroundImageUrl('') // No background image - using CSS starfield
                        .pointsData([]) // Will be populated by peer data
                        .pointColor(() => '#ff0000')
                        .pointAltitude(0.01)
                        .pointRadius(0.8)
                        .pointsMerge(false)
                        .atmosphereColor('#ff4444')
                        .atmosphereAltitude(0.15)
                        .showAtmosphere(true);
                    
                    // Position camera - move left and up to center in box
                    geoMap.pointOfView({ lat: 10, lng: -15, altitude: 2.3 }, 0);
                    
                    // Auto-rotate ONLY the globe (not background)
                    geoMap.controls().autoRotate = true;
                    geoMap.controls().autoRotateSpeed = 0.8;
                    geoMap.controls().enableZoom = true;
                    geoMap.controls().minDistance = 150;
                    geoMap.controls().maxDistance = 500;
                    
                    // Disable background rotation - globe spins, stars stay fixed
                    const scene = geoMap.scene();
                    if (scene && scene.rotation) {
                        scene.rotation.y = 0; // Lock background rotation
                    }
                    
                    // Pulsing animation for red dots
                    let pulseFactor = 0;
                    (function animate() {
                        try {
                            pulseFactor += 0.02;
                            const pulseScale = 0.8 + Math.sin(pulseFactor) * 0.3;
                            
                            if (geoMap && geoMap.pointsData && geoMap.pointsData().length > 0) {
                                geoMap.pointRadius(pulseScale);
                            }
                            
                            globeAnimationId = requestAnimationFrame(animate);
                        } catch (e) {
                            console.error('Globe animation error:', e);
                        }
                    })();
                    
                    log('üåç 3D Globe initialized - peers will light up the world in RED!');
                } else {
                    log('‚ö†Ô∏è Globe libraries loading... (refresh if not visible)', 'info');
                    console.warn('Globe or THREE not defined yet');
                }
            } catch (error) {
                console.error('Globe initialization error:', error);
                log('‚ùå Globe failed to load - check console', 'error');
                // Hide globe container on error
                document.getElementById('geo-map').style.display = 'none';
            }
        }, 1000); // Wait 1 second for libraries to fully load

        // ========================================
        // DISCORD LINKING
        // ========================================
        async function checkDiscordStatus() {
            try {
                const wallet = currentWallet;
                if (!wallet || wallet === 'pow_miner') return;

                const response = await fetch(`/api/discord/status?wallet_address=${encodeURIComponent(wallet)}`);
                if (!response.ok) return;

                const data = await response.json();
                const linkBtn = document.getElementById('discord-link-btn');
                const statusDiv = document.getElementById('discord-status');
                const usernameSpan = document.getElementById('discord-username');

                if (data.linked && data.discord_username) {
                    // Show status, hide button
                    linkBtn.style.display = 'none';
                    statusDiv.style.display = 'flex';
                    usernameSpan.textContent = data.discord_username;
                } else {
                    // Show button, hide status
                    linkBtn.style.display = 'block';
                    statusDiv.style.display = 'none';
                }
            } catch (error) {
                console.error('Failed to check Discord status:', error);
            }
        }

        async function linkDiscord() {
            try {
                const wallet = currentWallet;
                if (!wallet || wallet === 'pow_miner') {
                    log('‚ùå Please configure your wallet address first', 'error');
                    return;
                }

                const response = await fetch(`/api/discord/login?wallet_address=${encodeURIComponent(wallet)}`);
                if (!response.ok) {
                    log('‚ùå Failed to initiate Discord linking', 'error');
                    return;
                }

                const data = await response.json();
                log('üîó Redirecting to Discord for authorization...', 'info');
                window.location.href = data.url; // Redirect to Discord OAuth
            } catch (error) {
                console.error('Failed to link Discord:', error);
                log('‚ùå Failed to link Discord', 'error');
            }
        }

        // Discord button click handler
        document.getElementById('discord-link-btn').addEventListener('click', linkDiscord);

        // Check Discord status when approval status is loaded
        const originalLoadApprovalStatus = loadApprovalStatus;
        loadApprovalStatus = async function() {
            await originalLoadApprovalStatus();
            setTimeout(checkDiscordStatus, 500);
        };

        // Check Discord status periodically
        setInterval(checkDiscordStatus, 30000); // Check every 30 seconds

        // ========================================
        // Farm Mode Functions
        // ========================================

        async function farmRefresh() {
            try {
                const response = await fetch('/api/admin/farm/rigs');
                if (!response.ok) {
                    log('‚ùå Failed to load farm rigs', 'error');
                    return;
                }

                const data = await response.json();
                updateFarmUI(data);
            } catch (error) {
                console.error('Failed to refresh farm:', error);
                log('‚ùå Failed to refresh farm data', 'error');
            }
        }

        async function createRigConfig() {
            const rigName = document.getElementById('new-rig-name').value.trim();
            const connectionType = document.getElementById('rig-connection-type').value;
            const walletAddress = document.getElementById('rig-wallet-address').value.trim();
            const threads = document.getElementById('rig-threads').value;

            if (!rigName) {
                log('‚ùå Please enter a rig name', 'error');
                return;
            }

            try {
                const payload = {
                    rig_name: rigName,
                    mode: connectionType,
                    wallet_address: walletAddress || null,
                    threads: threads ? parseInt(threads) : null
                };

                const response = await fetch('/admin/farm/farmhand/create', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const error = await response.json();
                    log(`‚ùå Failed to create rig config: ${error.error}`, 'error');
                    return;
                }

                // Download the ZIP file
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `farmhand-${rigName.replace(/\s+/g, '-')}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);

                log(`‚úÖ FarmHand bundle created for "${rigName}". Extract and run on your mining rig!`, 'success');
                
                // Clear form
                document.getElementById('new-rig-name').value = '';
                document.getElementById('rig-wallet-address').value = '';
                document.getElementById('rig-threads').value = '';
            } catch (error) {
                console.error('Failed to create rig config:', error);
                log('‚ùå Failed to create rig configuration', 'error');
            }
        }

        function updateFarmUI(data) {
            // Update stats
            document.getElementById('farm-total-rigs').textContent = data.stats.total_rigs;
            document.getElementById('farm-online-rigs').textContent = data.stats.online_rigs;
            document.getElementById('farm-mining-rigs').textContent = data.stats.mining_rigs;
            document.getElementById('farm-total-hashrate').textContent = formatHashrate(data.stats.total_hashrate);

            // Update rigs list
            const rigsList = document.getElementById('farm-rigs-list');
            if (data.rigs.length === 0) {
                rigsList.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: var(--text-secondary);">
                        No rigs connected yet. Create a rig config above and run it on your mining machines.
                    </div>
                `;
                return;
            }

            rigsList.innerHTML = data.rigs.map(rig => {
                const statusColor = rig.status === 'mining' ? 'var(--accent-green)' : 
                                   rig.status === 'online' ? 'var(--accent-cyan)' : 
                                   rig.status === 'error' ? '#ef4444' : 'var(--text-secondary)';
                
                const statusBg = rig.status === 'mining' ? 'rgba(0, 255, 136, 0.15)' : 
                                 rig.status === 'online' ? 'rgba(0, 212, 255, 0.15)' : 
                                 rig.status === 'error' ? 'rgba(239, 68, 68, 0.15)' : 'rgba(100, 100, 100, 0.15)';
                
                return `
                    <div style="background: rgba(49, 37, 109, 0.3); border: 1px solid var(--border-color); border-radius: 8px; padding: 1rem; margin-bottom: 0.75rem;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.75rem;">
                            <div>
                                <div style="font-size: 1.1rem; font-weight: 600; color: var(--accent-purple); margin-bottom: 0.25rem;">
                                    ${rig.rig_id}
                                </div>
                                <div style="display: inline-block; padding: 0.25rem 0.75rem; background: ${statusBg}; border: 1px solid ${statusColor}; border-radius: 999px; font-size: 0.8rem;">
                                    <span style="color: ${statusColor};">‚óè ${rig.status.toUpperCase()}</span>
                                </div>
                            </div>
                            <div style="display: flex; gap: 0.5rem;">
                                ${rig.status === 'mining' ? 
                                    `<button onclick="farmStopRig('${rig.rig_id}')" class="btn btn-secondary" style="padding: 0.5rem 1rem; font-size: 0.85rem;">‚è∏Ô∏è Stop</button>` :
                                    `<button onclick="farmStartRig('${rig.rig_id}')" class="btn btn-primary" style="padding: 0.5rem 1rem; font-size: 0.85rem;">‚ñ∂Ô∏è Start</button>`
                                }
                                <button onclick="farmDeleteRig('${rig.rig_id}')" class="btn btn-secondary" style="padding: 0.5rem 1rem; font-size: 0.85rem;">üóëÔ∏è</button>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; padding-top: 0.75rem; border-top: 1px solid var(--border-color);">
                            <div>
                                <div style="color: var(--text-secondary); font-size: 0.75rem; margin-bottom: 0.25rem;">HASHRATE</div>
                                <div style="font-size: 1rem; font-weight: 600; color: var(--accent-cyan);">${formatHashrate(rig.hashrate)}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary); font-size: 0.75rem; margin-bottom: 0.25rem;">THREADS</div>
                                <div style="font-size: 1rem; font-weight: 600;">${rig.threads || '--'}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary); font-size: 0.75rem; margin-bottom: 0.25rem;">PROFILE</div>
                                <div style="font-size: 1rem; font-weight: 600;">${rig.profile || 'Default'}</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function farmStartRig(rigId) {
            try {
                const response = await fetch(`/api/admin/farm/rigs/${rigId}/start`, {
                    method: 'POST'
                });
                if (!response.ok) {
                    const error = await response.json();
                    log(`‚ùå Failed to start rig ${rigId}: ${error.error}`, 'error');
                    return;
                }

                log(`‚úÖ Started mining on rig ${rigId}`, 'success');
                setTimeout(farmRefresh, 500);
            } catch (error) {
                console.error('Failed to start rig:', error);
                log(`‚ùå Failed to start rig ${rigId}`, 'error');
            }
        }

        async function farmStopRig(rigId) {
            try {
                const response = await fetch(`/api/admin/farm/rigs/${rigId}/stop`, {
                    method: 'POST'
                });
                if (!response.ok) {
                    const error = await response.json();
                    log(`‚ùå Failed to stop rig ${rigId}: ${error.error}`, 'error');
                    return;
                }

                log(`‚è∏Ô∏è Stopped mining on rig ${rigId}`, 'success');
                setTimeout(farmRefresh, 500);
            } catch (error) {
                console.error('Failed to stop rig:', error);
                log(`‚ùå Failed to stop rig ${rigId}`, 'error');
            }
        }

        async function farmDeleteRig(rigId) {
            if (!confirm(`Are you sure you want to remove rig "${rigId}"?\n\nThis will disconnect it from the farm.`)) {
                return;
            }

            try {
                const response = await fetch(`/admin/farm/rigs/${rigId}`, {
                    method: 'DELETE'
                });
                if (!response.ok) {
                    const error = await response.json();
                    log(`‚ùå Failed to delete rig ${rigId}: ${error.error}`, 'error');
                    return;
                }

                log(`üóëÔ∏è Removed rig ${rigId} from farm`, 'success');
                setTimeout(farmRefresh, 500);
            } catch (error) {
                console.error('Failed to delete rig:', error);
                log(`‚ùå Failed to delete rig ${rigId}`, 'error');
            }
        }

        async function farmStartAll() {
            const response = await fetch('/api/admin/farm/rigs');
            const data = await response.json();
            for (const rig of data.rigs) {
                if (rig.status !== 'mining') {
                    await farmStartRig(rig.rig_id);
                }
            }
        }

        async function farmStopAll() {
            const response = await fetch('/api/admin/farm/rigs');
            const data = await response.json();
            for (const rig of data.rigs) {
                if (rig.status === 'mining') {
                    await farmStopRig(rig.rig_id);
                }
            }
        }

        async function openRigConfig(rigId) {
            try {
                const response = await fetch(`/api/admin/farm/rigs/${rigId}/config`);
                if (!response.ok) {
                    log(`‚ùå Failed to load config for rig ${rigId}`, 'error');
                    return;
                }

                const config = await response.json();
                showRigConfigDrawer(rigId, config);
            } catch (error) {
                console.error('Failed to load rig config:', error);
                log(`‚ùå Failed to load rig config`, 'error');
            }
        }

        function showRigConfigDrawer(rigId, config) {
            const drawer = document.getElementById('rig-config-drawer');
            const content = document.getElementById('rig-config-content');

            const profileType = config.profile?.profile_type || 'Performance';
            const scheduleEnabled = config.schedule ? true : false;

            content.innerHTML = `
                <div style="margin-bottom: 1.5rem;">
                    <h3 style="color: var(--accent-cyan); margin-bottom: 0.5rem;">Rig ID: ${rigId}</h3>
                    <p style="color: var(--text-secondary); font-size: 0.9rem;">Configure mining profiles and schedules</p>
                </div>

                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                        Mining Profile:
                    </label>
                    <select id="profile-select" class="wallet-input" style="width: 100%;">
                        <option value="Performance" ${profileType === 'Performance' ? 'selected' : ''}>‚ö° Performance (Max Threads)</option>
                        <option value="Eco" ${profileType === 'Eco' ? 'selected' : ''}>üåø Eco (50% Threads)</option>
                        <option value="Custom" ${profileType === 'Custom' ? 'selected' : ''}>‚öôÔ∏è Custom</option>
                    </select>
                </div>

                <div id="custom-threads-input" style="margin-bottom: 1.5rem; display: ${profileType === 'Custom' ? 'block' : 'none'};">
                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                        Custom Thread Count:
                    </label>
                    <input type="number" id="custom-threads" class="wallet-input" min="1" value="${config.profile?.thread_count || 4}" style="width: 100%;" />
                </div>

                <div style="margin-bottom: 1.5rem;">
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                        <input type="checkbox" id="schedule-enabled" ${scheduleEnabled ? 'checked' : ''} />
                        <span style="color: var(--text-secondary); font-size: 0.9rem;">Enable Time-based Schedule</span>
                    </label>
                </div>

                <div id="schedule-config" style="margin-bottom: 1.5rem; display: ${scheduleEnabled ? 'block' : 'none'};">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                        <div>
                            <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                                Start Hour (0-23):
                            </label>
                            <input type="number" id="schedule-start" class="wallet-input" min="0" max="23" value="${config.schedule?.start_hour || 0}" style="width: 100%;" />
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                                End Hour (0-23):
                            </label>
                            <input type="number" id="schedule-end" class="wallet-input" min="0" max="23" value="${config.schedule?.end_hour || 23}" style="width: 100%;" />
                        </div>
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                            Days of Week:
                        </label>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            ${['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].map((day, idx) => {
                                const checked = config.schedule?.days_of_week?.includes(idx + 1) || false;
                                return `
                                    <label style="display: flex; align-items: center; gap: 0.25rem; padding: 0.5rem 0.75rem; background: ${checked ? 'var(--accent-purple)' : 'rgba(255,255,255,0.1)'}; border-radius: 0.5rem; cursor: pointer;">
                                        <input type="checkbox" class="day-checkbox" value="${idx + 1}" ${checked ? 'checked' : ''} style="margin: 0;" />
                                        <span style="font-size: 0.85rem;">${day}</span>
                                    </label>
                                `;
                            }).join('')}
                        </div>
                    </div>
                </div>

                <div style="margin-bottom: 1.5rem;">
                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                        <input type="checkbox" id="auto-restart" ${config.auto_restart_on_error ? 'checked' : ''} />
                        <span style="color: var(--text-secondary); font-size: 0.9rem;">Auto-restart on Error</span>
                    </label>
                </div>

                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.9rem;">
                        Min Hashrate Threshold (H/s):
                    </label>
                    <input type="number" id="min-hashrate" class="wallet-input" min="0" value="${config.min_hashrate_threshold || 0}" style="width: 100%;" />
                    <p style="color: var(--text-secondary); font-size: 0.8rem; margin-top: 0.25rem;">
                        Trigger error if hashrate drops below this value (0 = disabled)
                    </p>
                </div>

                <div style="display: flex; gap: 0.5rem;">
                    <button onclick="saveRigConfig('${rigId}')" class="btn btn-primary" style="flex: 1;">
                        üíæ Save Configuration
                    </button>
                    <button onclick="closeRigConfig()" class="btn btn-secondary" style="flex: 1;">
                        ‚úï Cancel
                    </button>
                </div>
            `;

            // Event listeners for dynamic visibility
            content.querySelector('#profile-select').addEventListener('change', (e) => {
                const customInput = content.querySelector('#custom-threads-input');
                customInput.style.display = e.target.value === 'Custom' ? 'block' : 'none';
            });

            content.querySelector('#schedule-enabled').addEventListener('change', (e) => {
                const scheduleConfig = content.querySelector('#schedule-config');
                scheduleConfig.style.display = e.target.checked ? 'block' : 'none';
            });

            drawer.style.display = 'block';
        }

        function closeRigConfig() {
            document.getElementById('rig-config-drawer').style.display = 'none';
        }

        async function saveRigConfig(rigId) {
            try {
                const content = document.getElementById('rig-config-content');
                const profileType = content.querySelector('#profile-select').value;
                const scheduleEnabled = content.querySelector('#schedule-enabled').checked;
                const autoRestart = content.querySelector('#auto-restart').checked;
                const minHashrate = parseFloat(content.querySelector('#min-hashrate').value) || 0;

                const payload = {
                    auto_restart_on_error: autoRestart,
                    min_hashrate_threshold: minHashrate > 0 ? minHashrate : null
                };

                // Add profile
                payload.profile = {
                    profile_type: profileType
                };
                if (profileType === 'Custom') {
                    payload.profile.thread_count = parseInt(content.querySelector('#custom-threads').value) || 4;
                }

                // Add schedule if enabled
                if (scheduleEnabled) {
                    const startHour = parseInt(content.querySelector('#schedule-start').value) || 0;
                    const endHour = parseInt(content.querySelector('#schedule-end').value) || 23;
                    const days = Array.from(content.querySelectorAll('.day-checkbox:checked')).map(cb => parseInt(cb.value));

                    payload.schedule = {
                        profile: payload.profile,
                        start_hour: startHour,
                        end_hour: endHour,
                        days_of_week: days.length > 0 ? days : [1,2,3,4,5,6,7]
                    };
                }

                const response = await fetch(`/api/admin/farm/rigs/${rigId}/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const error = await response.json();
                    log(`‚ùå Failed to save config: ${error.error}`, 'error');
                    return;
                }

                log(`‚úÖ Configuration saved for rig ${rigId}`, 'success');
                closeRigConfig();
                setTimeout(farmRefresh, 500);
            } catch (error) {
                console.error('Failed to save rig config:', error);
                log('‚ùå Failed to save configuration', 'error');
            }
        }

        function formatHashrate(hashrate) {
            if (hashrate >= 1e9) return (hashrate / 1e9).toFixed(2) + ' GH/s';
            if (hashrate >= 1e6) return (hashrate / 1e6).toFixed(2) + ' MH/s';
            if (hashrate >= 1e3) return (hashrate / 1e3).toFixed(2) + ' KH/s';
            return hashrate.toFixed(0) + ' H/s';
        }

        // Auto-refresh farm data when in Farm mode
        setInterval(() => {
            if (currentMiningMode === 'Farm' && document.getElementById('farm-mode-section').style.display !== 'none') {
                farmRefresh();
            }
        }, 5000); // Refresh every 5 seconds
        
        // ========================================
        // NODE LINKING FUNCTIONALITY - Handled by linkNodeWithWallet() function above
        // ========================================
        
        // Sign message with Vision wallet's Ed25519 key (server-side signing)
        async function signMessageWithWallet(message, walletAddress) {
            try {
                log('üîê Signing message with Vision wallet...', 'info');
                
                // Call server-side signing endpoint
                const response = await fetch('/api/wallet/sign_message', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: message,
                        wallet_address: walletAddress
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(errorText || 'Signing failed');
                }
                
                const result = await response.json();
                log('‚úÖ Message signed successfully', 'success');
                
                return result.signature_b64;
            } catch (error) {
                console.error('Signing error:', error);
                log(`‚ùå Failed to sign message: ${error.message}`, 'error');
                return null;
            }
        }

        // ========================================
        // Testnet sunset detection removed - traditional PoW, no expiration
        // ========================================

    </script>

    <!-- Notification Bell -->
    <div class="vision-notification-bell" onclick="toggleVisionNotificationPanel()">
        <span style="font-size: 1.5rem;">üîî</span>
        <div id="visionNotificationBadge" class="vision-notification-badge" style="display: none;">0</div>
    </div>

    <!-- Notification Panel -->
    <div id="visionNotificationPanel" class="vision-notification-panel">
        <div class="vision-notification-panel-header">
            <h3>Notifications</h3>
            <button class="vision-notification-mark-read-btn" onclick="markAllVisionNotificationsRead()">Mark All Read</button>
        </div>
        <div class="vision-notification-panel-body" id="visionNotificationPanelBody">
            <div style="padding: 2rem; text-align: center; color: var(--muted);">Loading...</div>
        </div>
    </div>

    <script src="/shared-notifications.js"></script>
</body>
</html>
